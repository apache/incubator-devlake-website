<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>Apache DevLake (Incubating) Blog</title>
        <link>https://devlake.apache.org/blog</link>
        <description>Apache DevLake (Incubating) Blog</description>
        <lastBuildDate>Wed, 22 Jun 2022 00:00:00 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <language>en</language>
        <item>
            <title><![CDATA[refdiff插件的计算提交版本差异算法]]></title>
            <link>https://devlake.apache.org/blog/some-practices-of-supporting-postgresql</link>
            <guid>some-practices-of-supporting-postgresql</guid>
            <pubDate>Wed, 22 Jun 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[什么是 计算提交版本差异（CalculateCommitsDiff）？]]></description>
            <content:encoded><![CDATA[<h2 class="anchor anchorWithStickyNavbar_mojV" id="什么是-计算提交版本差异calculatecommitsdiff">什么是 <code>计算提交版本差异</code>（CalculateCommitsDiff）？<a class="hash-link" href="#什么是-计算提交版本差异calculatecommitsdiff" title="Direct link to heading">​</a></h2><p>我们常常需要计算两个<code>提交版本</code>之间的差异。具体的说，就是需要知道两个不同的<code>分支/标签</code>之间相差了哪些<code>提交版本</code>。</p><p>对于一般用户来说，通过<code>计算提交版本差异</code>，用户能迅速的判断两个不同的<code>分支/标签</code>之间在功能、BUG修复等等方面的区别。以帮助用户选择不同的<code>分支/标签</code>来使用。</p><p>而如果只是使用<code>diff</code>命令来查看这两个不同的<code>分支/标签</code>的话，大量庞杂冗余的代码修改信息就会毫无组织的混杂在其中，要从中提取出具体的功能变更之类的信息，等同于大海捞针。</p><p>对于一款致力于提升研发效能的产品来说，通过<code>计算提交版本差异</code>，就能查看一组组不同的<code>分支/标签</code>的变迁状况，这一数据的获取，有助于我们做进一步的效能分析。</p><p>例如，当一个项目的管理者，想要看看为什么最近的几个版本发版越来越慢了的时候。就可以对最近的几组<code>分支/标签</code>来计算<code>计算提交版本差异</code>。此时有些<code>分支/标签</code>组之间有着大量的<code>提交版本</code>，而有些<code>分支/标签</code>组之间有着较少的提交版本。项目管理者可以更进一步的计算这些提交版本各自的代码当量，把这些数据以图表的形式展示出来，最终得到一组很直观的<code>分支/标签</code>的图像。此时他或许就能发现，原来是因为最近的几次发版涉及到的变更越来越复杂了。通过这样的直观的信息，开发者和管理者们都能做出相应的调整，以便提升研发效能。</p><p><img loading="lazy" src="/assets/images/面板图片-03a197c811642b9877283665e88f49fa.png" width="2481" height="282" class="img_E7b_"></p><h2 class="anchor anchorWithStickyNavbar_mojV" id="已有的解决方案">已有的解决方案<a class="hash-link" href="#已有的解决方案" title="Direct link to heading">​</a></h2><p>当我们在<code>GitLab</code>上打开一个代码仓库的时候，我们可以通过在url末尾追加 compare 的方式来进入到仓库的比对页面。</p><p><img loading="lazy" src="data:image/png;base64,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" width="381" height="49" class="img_E7b_"></p><p><img loading="lazy" src="/assets/images/源分支-目标分支-99f50ad221ac3d6162e30ccd1e71a075.png" width="1345" height="949" class="img_E7b_"></p><p>在该页面，我们可以通过设置<code>源分支/标签</code> 和<code>目标分支/标签</code>让<code>GitLab</code>向我们展示 目标分支落后于源分支哪些版本，以及落后了多少个版本</p><p>设置完毕后，<code>GitLab</code>会展示如下</p><p><img loading="lazy" src="/assets/images/版本对比-d1d9959a319e4bb088379c7234097145.png" width="1741" height="1001" class="img_E7b_"></p><p>在这里，我们能看到我们选择的<code>目标分支/标签</code>比<code>源分支/标签</code>少了如图所示的<code>提交版本</code>（Commits）</p><p>然而遗憾的是，像<code>GitLab</code>这类解决方案，都没有做批量化，自动化的处理。也更没有对后续的计算出来的结果进行相应的数据汇总处理。用户面对海量的分支提交的时候，既不可能手动的一个一个去比较，也不可能手动的去把数据结果自己复制粘贴后再分析。</p><p>因此<code>DevLake</code>就必须要解决这个问题。</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="所谓的计算提交版本差异具体是在计算什么">所谓的<code>计算提交版本差异</code>具体是在计算什么？<a class="hash-link" href="#所谓的计算提交版本差异具体是在计算什么" title="Direct link to heading">​</a></h2><p>以<code>GitLab</code>的计算过程为例来说的话，所谓的<code>计算提交版本差异</code>也就是当一个<code>提交版本</code>在<code>源分支/标签</code>中<code>存在</code>，但是在<code>目标分支/标签</code>中<strong>不存在</strong>的时候，这个提交版本就会被<code>GitLab</code>给逮出来。</p><p>那么，或许有人会问，假如一个<code>提交版本</code>在<code>源分支/标签</code>中<strong>不存在</strong>，相反的，在<code>目标分支/标签</code>中<code>存在</code>，那是不是也会被抓起来呢？</p><p>答案是，<strong>不会</strong>。</p><p>也就是说，当我们计算<code>提交版本</code>的差异的时候，我们只关心<code>目标分支/标签</code>缺少了什么，而并不关心<code>目标分支/标签</code>多出来了什么东西。</p><p>这就好像以前有一位算法竞赛的学生，在NOI比赛结束后被相关学校面试的时候，一个劲的自我介绍自己担任过什么广播站青协学生会，什么会长副会长之类的经历。结果很快就惹得面试官老师们忍无可忍的告诫道：</p><blockquote><p>我们只想知道你信息学方面的自我介绍，其余的我都不感兴趣！！！</p></blockquote><p>在计算<code>提交版本</code>差异时，<code>GitLab</code>是这样。<code>GitHub</code>也是这样。事实上，在使用git命令 <code>git log branch1...branch2</code> 的时候，git也是这样的。</p><p>它们都只关心<code>目标分支/标签</code>相对于<code>源分支/标签</code>缺少的部分。</p><p>计算<code>提交版本</code>差异实际上就是</p><ul><li>计算待计算的<code>目标分支/标签</code>相对于<code>源分支/标签</code>缺少了哪些<code>提交版本</code></li></ul><h2 class="anchor anchorWithStickyNavbar_mojV" id="对提交版本进行数学建模">对<code>提交版本</code>进行数学建模<a class="hash-link" href="#对提交版本进行数学建模" title="Direct link to heading">​</a></h2><p>想要做计算，那么首先，我们需要把一个抽象的现实问题，转换成一个数学问题。</p><p>这里我们就需要进行数学建模了。</p><p>我们需要把像<code>目标分支/标签</code>、<code>源分支/标签</code>、<code>提交版本</code> 这样一系列的概念变成数学模型中的对象。</p><p>如此我们才能为其设计算法。</p><p>想当然的，我们就想到了使用图的方式来进行数学建模。</p><p>我们将每一个<code>提交版本</code>都看作是图上的一个节点，把<code>提交版本</code>合并之前的一组<code>提交版本</code>与当前<code>提交版本</code>之间的父子关系，看作成是一条<code>有向边</code></p><p>由于<code>目标分支</code>和<code>源分支</code>事实上也各自与一个特定的<code>提交版本</code>相绑定，因此也能将它们看作是图上的特别节点。</p><ul><li>将<code>目标分支/标签</code>所对应的节点，命名为<code>旧节点</code></li><li>将<code>源分支/标签</code>所对应的节点，命名为<code>新节点</code></li></ul><p>当然，这里我们还有一个需要特别关注的节点，就是初始的<code>提交版本</code>所代表的节点</p><ul><li>将初始<code>提交版本</code>所对应的节点，命名为<code>根节点</code></li></ul><p>上述的描述或许显得有点儿抽象。</p><p>我们现在来实际举一个例子。来看看如何对一个仓库进行上述数学建模</p><p>假设现在有基于如下描述而产生的一个仓库</p><ol><li>创建空仓库</li><li>在<code>main</code>分支上创建<code>提交版本</code> <code>1</code>作为初始提交</li><li>在<code>main</code>分支上创建<code>提交版本</code> <code>2</code></li><li>在<code>main</code>分支上创建新分支<code>nd</code></li><li>在<code>nd</code>分支上创建<code>提交版本</code> <code>3</code></li><li>在<code>main</code>分支上创建<code>提交版本</code> <code>4</code></li><li>在<code>main</code>分支上创建新分支<code>dtf</code></li><li>在<code>main</code>分支上创建<code>提交版本</code> <code>5</code></li><li>在<code>dtf</code>分支上创建<code>提交版本</code> <code>6</code></li><li>在<code>main</code>分支上创建新分支<code>nddtf</code></li><li>在<code>nddtf</code>分支上创建<code>提交版本</code> <code>7</code></li><li>把<code>nd</code>分支合并到<code>nddtf</code>分支</li><li>把<code>dtf</code>分支合并到<code>nddtf</code>分支</li><li>在<code>main</code>分支上创建<code>提交版本</code> <code>8</code></li><li>在<code>nddtf</code>分支上创建<code>提交版本</code> <code>9</code></li></ol><p>我们对上述的仓库进行构图之后，最终会得到如下图所示的一个有向图：</p><p><img loading="lazy" src="/assets/images/数学模型构图-4a78a881d229f093e4da55b862af4108.png" width="1161" height="733" class="img_E7b_"></p><ul><li>此时彩色节点<code>1</code>为<code>根节点</code></li><li><code>main</code>分支为<code>1</code> <code>2</code> <code>4</code> <code>5</code> <code>8</code></li><li><code>nd</code>分支为<code>1</code> <code>2</code> <code>3</code> 随后合并入 <code>nddtf</code> 分支</li><li><code>dtf</code>分支为<code>1</code> <code>2</code> <code>4</code> <code>6</code> 随后合并入 <code>nddtf</code> 分支</li><li><code>nddtf</code> 分支为 <code>1</code> <code>2</code> <code>3</code> <code>4</code> <code>5</code> <code>6</code> <code>7</code> <code>9</code></li></ul><p>可以看到，每一个<code>提交版本</code>在图中都相对应的有一个节点</p><p>此时我们把<code>提交版本</code> <code>1</code>所代表的节点，作为<code>根节点</code></p><p>当然这里可能会有同学提问了：</p><ul><li>假如我这个仓库有<strong>一万个</strong><code>根节点</code>怎么破？</li></ul><p>相信一些经常做图的建模的同学应该都知道破法。</p><ul><li>创建一个名叫为<code>一万个根节点</code>的虚拟节点，把它设为这些个虚假的<code>根节点</code>的父节点，来当作真正的<code>根节点</code>即可。</li></ul><p>在这个有向图中，我们并没有实际的去指定具体的<code>目标分支/标签</code>或者<code>源分支/标签</code></p><p>在实际使用中，我们可以把任意的两个<code>提交版本</code>作为一对<code>目标分支/标签</code>和<code>源分支/标签</code>
当然，有的同学在这里可能又会产生一个问题：</p><ul><li><code>目标分支/标签</code>和<code>源分支/标签</code> 虽然都能映射到其最后的<code>提交版本</code>上，但是实际上来说<code>提交版本</code>与<code>分支/标签</code>本质上就是两种不同的概念。</li></ul><p><code>分支/标签</code>的实质，是包含一系列的<code>提交版本</code>的集合。而特定的<code>提交版本</code>仅仅是这个集合中的最后一个元素罢了。</p><p>当我们把一个仓库通过上述数学建模抽象成一个有向图之后，这个集合的信息，会因此而丢失掉吗？</p><p>对于一个合法的仓库来说，答案显然是，<code>不会</code></p><p>实际上，这也就是为什么我们一定要在该有向图中强调<code>根节点</code>的原因。</p><p>我们这里这里，先给出结论：</p><p><strong><code>分支/标签</code>所对应的节点，到<code>根节点</code>的全部路径中途径的<code>所有节点</code>的集合，即为该<code>分支/标签</code>所包含的<code>提交版本</code>集合。</strong></p><h2 class="anchor anchorWithStickyNavbar_mojV" id="简单证明-上述结论">简单证明 上述结论<a class="hash-link" href="#简单证明-上述结论" title="Direct link to heading">​</a></h2><ul><li>设<code>根节点</code>为节点<code>A</code></li><li>设要求的<code>分支/标签</code>所代表的节点为节点<code>B</code></li></ul><hr><ul><li>当 节点<code>C</code>是属于要求的<code>分支/标签</code></li><li>因为 节点<code>C</code>是属于要求的<code>分支/标签</code></li><li>所以 必然存在一组提交或者合并 使得 节点<code>C</code> 可以一直提交到节点 <code>B</code></li><li>又因为 每一个新增的提交 或者 合并操作，均会切实的建立一条从新增的提交/合并到当前提交的边</li><li>所以，反过来说，每一个提交或者合并后的节点，均可以抵达节点<code>C</code></li><li>所以 节点<code>B</code>存在至少一条路径 可以 抵达节点<code>C</code></li><li>同理可证，节点<code>C</code>存在至少一条路径抵达<code>根节点</code> 也就是节点<code>A</code></li><li>综上，存在一条从节点<code>B</code>到节点<code>A</code>的路径，经过节点<code>C</code></li></ul><hr><ul><li>当 节点<code>C</code>不属于要求的<code>分支/标签</code></li><li>假设 存在一条从节点<code>B</code>到节点<code>A</code>的路径，经过节点<code>C</code></li><li>因为 每一条边都是由新增的提交或者合并操作建立的</li><li>所以 必然存在一系列的新增提交或者合并操作，使得节点<code>C</code>成为节点<code>B</code></li><li>又因为 每一个提交在抽象逻辑上都是独一无二的</li><li>因此，如果缺失了节点<code>C</code>则必然导致在构建节点<code>B</code>所代表的<code>分支/标签</code>的过程中，至少存在一个提交或者合并操作无法执行。</li><li>这将导致分支非法</li><li>因此 假设不成立</li><li>因此 其逆否命题 对任意一条从节点<code>B</code>到节点<code>A</code>的路径，都不会经过节点<code>C</code> 成立</li></ul><hr><ul><li>根据 </li><li>当 节点<code>C</code>是属于要求的<code>分支/标签</code>，存在一条从节点<code>B</code>到节点<code>A</code>的路径，经过节点<code>C</code> （必要性）</li><li>当 节点<code>C</code>不属于要求的<code>分支/标签</code>，对任意一条从节点<code>B</code>到节点<code>A</code>的路径，都不会经过节点<code>C</code> （充分性）</li><li>可得 <code>分支/标签</code>所对应的节点，到<code>根节点</code>的全部路径中途径的<code>所有节点</code>的集合，即为该<code>分支/标签</code>所包含的<code>提交版本</code>集合。</li></ul><h2 class="anchor anchorWithStickyNavbar_mojV" id="算法选择">算法选择<a class="hash-link" href="#算法选择" title="Direct link to heading">​</a></h2><p>我们现在已经完成了数学建模，并且已经为数学建模做了基本的证明。现在，我们终于可以开始在这个数学模型的基础上来设计并实现我们的算法了。</p><p>如果没有做上述基本论证的同学，这里可能会犯一个小错误：那就是它们会误以为，只要计算两个节点之间的最短路径即可。若真是如此的话，<code>SPFA</code>，<code>迪杰斯特拉</code>（Dijkstra），甚至头铁一点儿，来个<code>弗洛伊德</code>（Floyd）都是很容易想到的。当然由于该有向图的所有边长都是1，所以更简单的方法是直接使用<code>广/宽度优先搜索算法（BFS）</code>来计算最短路。</p><p>上述的一系列耳熟能详的算法，或多或少都有成熟的库可以直接使用。但是遗憾的是，如果真的是去算最短路的话，那最终结果恐怕会不尽如人意。</p><p>在<code>DevLake</code>的早期不成熟的版本中，曾经使用过最短路的算法来计算。尽管对于比较简单线性的仓库来说，可以歪打正着的算出结果。但是当仓库的分支和合并变得复杂的时候，最短路所计算的结果往往都会遗漏大量的<code>提交版本</code>。</p><p>因为在刚才我们已经论证过了，这个<code>分支/标签</code>所包含的<code>提交版本</code>集合，是必须要全部路径才行的。只有全部路径，才能满足充分且必要条件。</p><p>也就是说，中间只要漏了一条路径，那就会漏掉一系列的<code>提交版本</code></p><p>要计算这个有向图上的<code>旧节点</code>所代表的<code>分支/标签</code>比<code>新节点</code>所代表的<code>分支/标签</code>缺少了哪些<code>提交版本</code></p><p>实质上就是在计算<code>旧节点</code>到<code>根节点</code>的全部路径所经节点，对比<code>新节点</code>到<code>根节点</code>的全部路径所经节点，缺少了哪些节点。</p><p>如果我们数学建模的时候，把这个有向图建立成一棵树的话</p><p>那么熟悉算法的同学，就可以很自然的使用最近公共祖先（LCA）算法，求出其并集，然后再来计算其对应的缺失的部分。</p><p>但是作为一个有向图来说，树结构的算法是没法直接使用的。所幸的是，我们的这个图，在由合法仓库生成的情况下，必然是一个有向无环图。</p><p>一个有向无环图，也是有自己的最近公共祖先（LCA）算法的。</p><p>只是，这里有两个问题</p><ul><li>我们真的对 最近公共祖先 这个特定的节点感兴趣吗？</li><li>在有多个不同路径的公共祖先的情况下，只求一个最近公共祖先有什么意义呢？</li></ul><p>首先，我们需要明确我们的需求</p><p>我们只是为了计算 </p><ul><li><code>旧节点</code>到<code>根节点</code>的全部路径所经节点，对比<code>新节点</code>到<code>根节点</code>的全部路径所经节点，缺少了哪些节点。</li></ul><p>除此之外的，我们不感兴趣。</p><p>换句话说，我们想知道其公共祖先，但是，不关心它是不是最近的。</p><p>它是近的也好，它是远的也罢，只要是公共祖先，都得抓起来。去求最近公共祖先，在树结构下，可以近似等价于求其全部祖先。因此可以使用该算法。</p><p>但是在有向无环图下，最近公共祖先就是个废物。求出来了又能如何？</p><p>根本上，还是应该去求全部的公共祖先。</p><p>所以我们别无选择，只能用最直接的算法。</p><ul><li>计算出<code>旧节点</code>到<code>根节点</code>的全部路径所经节点</li><li>计算出<code>新节点</code>到<code>根节点</code>的全部路径所经节点</li><li>检查<code>新节点</code>的全部路径所经节点缺少了哪些节点</li></ul><p>如何计算任意节点到<code>根节点</code>的全部路径所经节点？</p><p>在OI上熟练于骗分导论的同学们，应该很自然的就意识到了</p><p><code>深度优先搜索（DFS）</code></p><p>当然，这里补充一下，由于<code>根节点</code>的性质，事实上，无论是从哪个方向出发，无论走那条边，只要是能走的边，最终都会抵达<code>根节点</code></p><p>因此，在上述条件成立的基础上，没有记录路径状态的<code>广/宽度优先搜索（BFS）</code>也是可以使用的。因为在必然能抵达<code>根节点</code>的前提下，可以忽略路径状态，不做路径的可行性判断。</p><p>当然，这一前提，也有利于我们<code>深度优先搜索（DFS）</code>进行优化。</p><p>在我们执行<code>深度优先搜索（DFS）</code>的时候，我们可以将所有访问到的节点，均添加到集合中，而无需等待确认该节点能确实抵达<code>根节点</code>后再进行添加。</p><p>实际上这里在一个问题上我们又会出现了两种分歧。
问题是，如何将一个节点添加到集合中。方案有如下两种。</p><p>染色法：添加到集合中的节点进行染色，未添加到集合中的节点不进行染色。
集合法：使用平衡树算法建立一个集合，将节点添加到该集合中。</p><p>这两种算法各有优劣。</p><ul><li>染色法的优势在于，染色法添加一个元素的时间复杂度是O(1)的，快准狠。相比较而言，集合法添加一个元素的时间复杂度是O(log(n))。</li><li>集合法的优势在于，集合法遍历所有元素的时间复杂度是O(n)的，而染色法下，要遍历所有元素时间复杂度会是O(m)，同时集合法可以通过设计一个优秀的hash算法代替平衡树，来将时间复杂度优化到接近O(1).（这里n表示集合大小，m表示整个图的大小）</li></ul><p>我们这里选择使用集合法。实际上这两种算法都差不多。</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="算法实现">算法实现<a class="hash-link" href="#算法实现" title="Direct link to heading">​</a></h2><ul><li>根据提交建图</li><li>我们对<code>旧节点</code>使用<code>深度优先搜索（DFS）</code>计算出其到<code>根节点</code>的全部路径所经节点，添加到<code>集合A</code>中</li><li>接着，我们对<code>新节点</code>使用<code>深度优先搜索（DFS）</code>计算出其到<code>根节点</code>的全部路径所经节点，添加到<code>集合B</code></li><li>注意，这里有一个优化，这个优化是建立在我们的需求上</li><li>重复一遍我们的需求</li><li>我们只关心<code>目标分支/标签</code>缺少了什么，而并不关心<code>目标分支/标签</code>多出来了什么东西。</li><li>因此当对<code>新节点</code>使用<code>深度优先搜索（DFS）</code>搜索到已经在<code>集合A</code>中的节点时，可以认为该节点已搜索过，无需再次搜索。</li><li>此时的<code>集合B</code>，可以恰好的避开<code>集合A</code>中已有的所有节点，因此，恰好就是我们所需的结果。</li></ul><p>核心的计算代码如下所示：</p><div class="codeBlockContainer_I0IT language-golang theme-code-block"><div class="codeBlockContent_wNvx" style="color:#393A34;background-color:#f6f8fa"><pre tabindex="0" class="prism-code language-golang codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">oldGroup := make(map[string]*CommitNode)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">var dfs func(*CommitNode)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// put all commit sha which can be depth-first-searched by old commit</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">dfs = func(now *CommitNode) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if _, ok = oldGroup[now.Sha]; ok {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    oldGroup[now.Sha] = now</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for _, node := range now.Parent {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        dfs(node)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">dfs(oldCommitNode)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">var newGroup = make(map[string]*CommitNode)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// put all commit sha which can be depth-first-searched by new commit, will stop when find any in either group</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">dfs = func(now *CommitNode) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if _, ok = oldGroup[now.Sha]; ok {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if _, ok = newGroup[now.Sha]; ok {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    newGroup[now.Sha] = now</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    lostSha = append(lostSha, now.Sha)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for _, node := range now.Parent {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        dfs(node)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">dfs(newCommitNode)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><p>这里的lostSha即为我们最终求得的缺失的部分</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="算法执行的演示动画">算法执行的演示动画<a class="hash-link" href="#算法执行的演示动画" title="Direct link to heading">​</a></h2><p>我们用一个简陋的动画来简单的演示一下，上述算法在逻辑上执行的情况。</p><ul><li><code>旧节点</code>为节点<code>8</code></li><li><code>新节点</code>为节点<code>9</code></li></ul><p><img loading="lazy" src="/assets/images/dfs-3464f1398b150e893646c4f21e95ea10.gif" width="868" height="634" class="img_E7b_"></p><p>如上述动画所演示的一般
从节点<code>8</code>开始执行<code>深度优先搜索（DFS）</code>到<code>根节点</code>中止
从节点<code>9</code>开始执行<code>深度优先搜索（DFS）</code>到已经在节点<code>8</code>的集合中的节点为止
此时，在节点<code>9</code>执行<code>深度优先搜索（DFS）</code>过程中被访问到的所有非节点<code>8</code>的节点</p><ul><li>节点<code>3</code></li><li>节点<code>6</code></li><li>节点<code>7</code></li><li>节点<code>9</code> </li></ul><p>它们所对应的<code>提交版本</code>就是我们要求的差集</p><blockquote><p>此时最短路为 <code>9</code> -&gt; <code>7</code> -&gt; <code>5</code> -&gt; <code>8</code>
此时最近公共父节点为 <code>5</code>，到该节点的路径为 <code>9</code> -&gt; <code>7</code> -&gt; <code>5</code>
从上图中也可以直观的看到如果使用最短路算法，或者最近公共父节点算法的情况下，我们是无法得到正确答案的。</p></blockquote><h2 class="anchor anchorWithStickyNavbar_mojV" id="时空复杂度">时空复杂度<a class="hash-link" href="#时空复杂度" title="Direct link to heading">​</a></h2><p>设<code>提交版本</code>的总大小为m，每一组<code>源分支/标签</code>和<code>目标分支/标签</code>的平均大小为n,一共有k组数据</p><p>DFS每访问一个节点，需要执行一次加入集合操作。我们按照我们实际实现中使用的 平衡树算法来计算 时间复杂度为 O(log(n))</p><p>此时我们可以计算得出</p><ul><li>建图的时间复杂度：O(m)</li><li>计算一组<code>源分支/标签</code>和<code>目标分支/标签</code>时间复杂度：O(n<!-- -->*<!-- -->log(n))</li><li>计算所有<code>源分支/标签</code>和<code>目标分支/标签</code>时间复杂度：O(k<!-- -->*<!-- -->n<!-- -->*<!-- -->log(n))</li><li>读取、统计结果时间复杂度：O(k<!-- -->*<!-- -->n)</li><li>总体时间复杂度:O(m + k<!-- -->*<!-- -->n<!-- -->*<!-- -->log(n))</li></ul><hr><ul><li>图的空间复杂度：O(m)</li><li>每组<code>源分支/标签</code>和<code>目标分支/标签</code>集合的空间复杂度：O(n) （非并发情况下，k组数据可共用）</li><li>总体空间复杂度：O(m+n)</li></ul><h2 class="anchor anchorWithStickyNavbar_mojV" id="关键词">关键词<a class="hash-link" href="#关键词" title="Direct link to heading">​</a></h2><ul><li><code>DevLake</code></li><li><code>CalculateCommitsDiff</code></li><li><code>算法</code></li><li><code>数学建模</code></li><li><code>证明逻辑</code></li><li><code>充分条件</code></li><li><code>必要条件</code></li><li><code>图论</code></li><li><code>深度优先搜索（DFS）</code></li><li><code>广/宽度优先搜索（BFS）</code></li><li><code>时间复杂度</code></li><li><code>空间复杂度</code></li><li><code>时空复杂度</code></li></ul>]]></content:encoded>
            <category>devlake</category>
            <category>refdiff</category>
            <category>algorithm</category>
            <category>graph</category>
        </item>
        <item>
            <title><![CDATA[Apache DevLake 兼容 PostgreSQL 踩坑小结]]></title>
            <link>https://devlake.apache.org/blog/some-practices-of-supporting-postgresql</link>
            <guid>some-practices-of-supporting-postgresql</guid>
            <pubDate>Fri, 17 Jun 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[本文作者：ZhangLiang]]></description>
            <content:encoded><![CDATA[<h2 class="anchor anchorWithStickyNavbar_mojV" id="什么是-计算提交版本差异calculatecommitsdiff">什么是 <code>计算提交版本差异</code>（CalculateCommitsDiff）？<a class="hash-link" href="#什么是-计算提交版本差异calculatecommitsdiff" title="Direct link to heading">​</a></h2><p>我们常常需要计算两个<code>提交版本</code>之间的差异。具体的说，就是需要知道两个不同的<code>分支/标签</code>之间相差了哪些<code>提交版本</code>。</p><p>对于一般用户来说，通过<code>计算提交版本差异</code>，用户能迅速的判断两个不同的<code>分支/标签</code>之间在功能、BUG修复等等方面的区别。以帮助用户选择不同的<code>分支/标签</code>来使用。</p><p>而如果只是使用<code>diff</code>命令来查看这两个不同的<code>分支/标签</code>的话，大量庞杂冗余的代码修改信息就会毫无组织的混杂在其中，要从中提取出具体的功能变更之类的信息，等同于大海捞针。</p><p>对于一款致力于提升研发效能的产品来说，通过<code>计算提交版本差异</code>，就能查看一组组不同的<code>分支/标签</code>的变迁状况，这一数据的获取，有助于我们做进一步的效能分析。</p><p>例如，当一个项目的管理者，想要看看为什么最近的几个版本发版越来越慢了的时候。就可以对最近的几组<code>分支/标签</code>来计算<code>计算提交版本差异</code>。此时有些<code>分支/标签</code>组之间有着大量的<code>提交版本</code>，而有些<code>分支/标签</code>组之间有着较少的提交版本。项目管理者可以更进一步的计算这些提交版本各自的代码当量，把这些数据以图表的形式展示出来，最终得到一组很直观的<code>分支/标签</code>的图像。此时他或许就能发现，原来是因为最近的几次发版涉及到的变更越来越复杂了。通过这样的直观的信息，开发者和管理者们都能做出相应的调整，以便提升研发效能。</p><p><img loading="lazy" src="/assets/images/面板图片-03a197c811642b9877283665e88f49fa.png" width="2481" height="282" class="img_E7b_"></p><h2 class="anchor anchorWithStickyNavbar_mojV" id="已有的解决方案">已有的解决方案<a class="hash-link" href="#已有的解决方案" title="Direct link to heading">​</a></h2><p>当我们在<code>GitLab</code>上打开一个代码仓库的时候，我们可以通过在url末尾追加 compare 的方式来进入到仓库的比对页面。</p><p><img loading="lazy" src="data:image/png;base64,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" width="381" height="49" class="img_E7b_"></p><p><img loading="lazy" src="/assets/images/源分支-目标分支-99f50ad221ac3d6162e30ccd1e71a075.png" width="1345" height="949" class="img_E7b_"></p><p>在该页面，我们可以通过设置<code>源分支/标签</code> 和<code>目标分支/标签</code>让<code>GitLab</code>向我们展示 目标分支落后于源分支哪些版本，以及落后了多少个版本</p><p>设置完毕后，<code>GitLab</code>会展示如下</p><p><img loading="lazy" src="/assets/images/版本对比-d1d9959a319e4bb088379c7234097145.png" width="1741" height="1001" class="img_E7b_"></p><p>在这里，我们能看到我们选择的<code>目标分支/标签</code>比<code>源分支/标签</code>少了如图所示的<code>提交版本</code>（Commits）</p><p>然而遗憾的是，像<code>GitLab</code>这类解决方案，都没有做批量化，自动化的处理。也更没有对后续的计算出来的结果进行相应的数据汇总处理。用户面对海量的分支提交的时候，既不可能手动的一个一个去比较，也不可能手动的去把数据结果自己复制粘贴后再分析。</p><p>因此<code>DevLake</code>就必须要解决这个问题。</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="所谓的计算提交版本差异具体是在计算什么">所谓的<code>计算提交版本差异</code>具体是在计算什么？<a class="hash-link" href="#所谓的计算提交版本差异具体是在计算什么" title="Direct link to heading">​</a></h2><p>以<code>GitLab</code>的计算过程为例来说的话，所谓的<code>计算提交版本差异</code>也就是当一个<code>提交版本</code>在<code>源分支/标签</code>中<code>存在</code>，但是在<code>目标分支/标签</code>中<strong>不存在</strong>的时候，这个提交版本就会被<code>GitLab</code>给逮出来。</p><p>那么，或许有人会问，假如一个<code>提交版本</code>在<code>源分支/标签</code>中<strong>不存在</strong>，相反的，在<code>目标分支/标签</code>中<code>存在</code>，那是不是也会被抓起来呢？</p><p>答案是，<strong>不会</strong>。</p><p>也就是说，当我们计算<code>提交版本</code>的差异的时候，我们只关心<code>目标分支/标签</code>缺少了什么，而并不关心<code>目标分支/标签</code>多出来了什么东西。</p><p>这就好像以前有一位算法竞赛的学生，在NOI比赛结束后被相关学校面试的时候，一个劲的自我介绍自己担任过什么广播站青协学生会，什么会长副会长之类的经历。结果很快就惹得面试官老师们忍无可忍的告诫道：</p><blockquote><p>我们只想知道你信息学方面的自我介绍，其余的我都不感兴趣！！！</p></blockquote><p>在计算<code>提交版本</code>差异时，<code>GitLab</code>是这样。<code>GitHub</code>也是这样。事实上，在使用git命令 <code>git log branch1...branch2</code> 的时候，git也是这样的。</p><p>它们都只关心<code>目标分支/标签</code>相对于<code>源分支/标签</code>缺少的部分。</p><p>计算<code>提交版本</code>差异实际上就是</p><ul><li>计算待计算的<code>目标分支/标签</code>相对于<code>源分支/标签</code>缺少了哪些<code>提交版本</code></li></ul><h2 class="anchor anchorWithStickyNavbar_mojV" id="对提交版本进行数学建模">对<code>提交版本</code>进行数学建模<a class="hash-link" href="#对提交版本进行数学建模" title="Direct link to heading">​</a></h2><p>想要做计算，那么首先，我们需要把一个抽象的现实问题，转换成一个数学问题。</p><p>这里我们就需要进行数学建模了。</p><p>我们需要把像<code>目标分支/标签</code>、<code>源分支/标签</code>、<code>提交版本</code> 这样一系列的概念变成数学模型中的对象。</p><p>如此我们才能为其设计算法。</p><p>想当然的，我们就想到了使用图的方式来进行数学建模。</p><p>我们将每一个<code>提交版本</code>都看作是图上的一个节点，把<code>提交版本</code>合并之前的一组<code>提交版本</code>与当前<code>提交版本</code>之间的父子关系，看作成是一条<code>有向边</code></p><p>由于<code>目标分支</code>和<code>源分支</code>事实上也各自与一个特定的<code>提交版本</code>相绑定，因此也能将它们看作是图上的特别节点。</p><ul><li>将<code>目标分支/标签</code>所对应的节点，命名为<code>旧节点</code></li><li>将<code>源分支/标签</code>所对应的节点，命名为<code>新节点</code></li></ul><p>当然，这里我们还有一个需要特别关注的节点，就是初始的<code>提交版本</code>所代表的节点</p><ul><li>将初始<code>提交版本</code>所对应的节点，命名为<code>根节点</code></li></ul><p>上述的描述或许显得有点儿抽象。</p><p>我们现在来实际举一个例子。来看看如何对一个仓库进行上述数学建模</p><p>假设现在有基于如下描述而产生的一个仓库</p><ol><li>创建空仓库</li><li>在<code>main</code>分支上创建<code>提交版本</code> <code>1</code>作为初始提交</li><li>在<code>main</code>分支上创建<code>提交版本</code> <code>2</code></li><li>在<code>main</code>分支上创建新分支<code>nd</code></li><li>在<code>nd</code>分支上创建<code>提交版本</code> <code>3</code></li><li>在<code>main</code>分支上创建<code>提交版本</code> <code>4</code></li><li>在<code>main</code>分支上创建新分支<code>dtf</code></li><li>在<code>main</code>分支上创建<code>提交版本</code> <code>5</code></li><li>在<code>dtf</code>分支上创建<code>提交版本</code> <code>6</code></li><li>在<code>main</code>分支上创建新分支<code>nddtf</code></li><li>在<code>nddtf</code>分支上创建<code>提交版本</code> <code>7</code></li><li>把<code>nd</code>分支合并到<code>nddtf</code>分支</li><li>把<code>dtf</code>分支合并到<code>nddtf</code>分支</li><li>在<code>main</code>分支上创建<code>提交版本</code> <code>8</code></li><li>在<code>nddtf</code>分支上创建<code>提交版本</code> <code>9</code></li></ol><p>我们对上述的仓库进行构图之后，最终会得到如下图所示的一个有向图：</p><p><img loading="lazy" src="/assets/images/数学模型构图-4a78a881d229f093e4da55b862af4108.png" width="1161" height="733" class="img_E7b_"></p><ul><li>此时彩色节点<code>1</code>为<code>根节点</code></li><li><code>main</code>分支为<code>1</code> <code>2</code> <code>4</code> <code>5</code> <code>8</code></li><li><code>nd</code>分支为<code>1</code> <code>2</code> <code>3</code> 随后合并入 <code>nddtf</code> 分支</li><li><code>dtf</code>分支为<code>1</code> <code>2</code> <code>4</code> <code>6</code> 随后合并入 <code>nddtf</code> 分支</li><li><code>nddtf</code> 分支为 <code>1</code> <code>2</code> <code>3</code> <code>4</code> <code>5</code> <code>6</code> <code>7</code> <code>9</code></li></ul><p>可以看到，每一个<code>提交版本</code>在图中都相对应的有一个节点</p><p>此时我们把<code>提交版本</code> <code>1</code>所代表的节点，作为<code>根节点</code></p><p>当然这里可能会有同学提问了：</p><ul><li>假如我这个仓库有<strong>一万个</strong><code>根节点</code>怎么破？</li></ul><p>相信一些经常做图的建模的同学应该都知道破法。</p><ul><li>创建一个名叫为<code>一万个根节点</code>的虚拟节点，把它设为这些个虚假的<code>根节点</code>的父节点，来当作真正的<code>根节点</code>即可。</li></ul><p>在这个有向图中，我们并没有实际的去指定具体的<code>目标分支/标签</code>或者<code>源分支/标签</code></p><p>在实际使用中，我们可以把任意的两个<code>提交版本</code>作为一对<code>目标分支/标签</code>和<code>源分支/标签</code>
当然，有的同学在这里可能又会产生一个问题：</p><ul><li><code>目标分支/标签</code>和<code>源分支/标签</code> 虽然都能映射到其最后的<code>提交版本</code>上，但是实际上来说<code>提交版本</code>与<code>分支/标签</code>本质上就是两种不同的概念。</li></ul><p><code>分支/标签</code>的实质，是包含一系列的<code>提交版本</code>的集合。而特定的<code>提交版本</code>仅仅是这个集合中的最后一个元素罢了。</p><p>当我们把一个仓库通过上述数学建模抽象成一个有向图之后，这个集合的信息，会因此而丢失掉吗？</p><p>对于一个合法的仓库来说，答案显然是，<code>不会</code></p><p>实际上，这也就是为什么我们一定要在该有向图中强调<code>根节点</code>的原因。</p><p>我们这里这里，先给出结论：</p><p><strong><code>分支/标签</code>所对应的节点，到<code>根节点</code>的全部路径中途径的<code>所有节点</code>的集合，即为该<code>分支/标签</code>所包含的<code>提交版本</code>集合。</strong></p><h2 class="anchor anchorWithStickyNavbar_mojV" id="简单证明-上述结论">简单证明 上述结论<a class="hash-link" href="#简单证明-上述结论" title="Direct link to heading">​</a></h2><ul><li>设<code>根节点</code>为节点<code>A</code></li><li>设要求的<code>分支/标签</code>所代表的节点为节点<code>B</code></li></ul><hr><ul><li>当 节点<code>C</code>是属于要求的<code>分支/标签</code></li><li>因为 节点<code>C</code>是属于要求的<code>分支/标签</code></li><li>所以 必然存在一组提交或者合并 使得 节点<code>C</code> 可以一直提交到节点 <code>B</code></li><li>又因为 每一个新增的提交 或者 合并操作，均会切实的建立一条从新增的提交/合并到当前提交的边</li><li>所以，反过来说，每一个提交或者合并后的节点，均可以抵达节点<code>C</code></li><li>所以 节点<code>B</code>存在至少一条路径 可以 抵达节点<code>C</code></li><li>同理可证，节点<code>C</code>存在至少一条路径抵达<code>根节点</code> 也就是节点<code>A</code></li><li>综上，存在一条从节点<code>B</code>到节点<code>A</code>的路径，经过节点<code>C</code></li></ul><hr><ul><li>当 节点<code>C</code>不属于要求的<code>分支/标签</code></li><li>假设 存在一条从节点<code>B</code>到节点<code>A</code>的路径，经过节点<code>C</code></li><li>因为 每一条边都是由新增的提交或者合并操作建立的</li><li>所以 必然存在一系列的新增提交或者合并操作，使得节点<code>C</code>成为节点<code>B</code></li><li>又因为 每一个提交在抽象逻辑上都是独一无二的</li><li>因此，如果缺失了节点<code>C</code>则必然导致在构建节点<code>B</code>所代表的<code>分支/标签</code>的过程中，至少存在一个提交或者合并操作无法执行。</li><li>这将导致分支非法</li><li>因此 假设不成立</li><li>因此 其逆否命题 对任意一条从节点<code>B</code>到节点<code>A</code>的路径，都不会经过节点<code>C</code> 成立</li></ul><hr><ul><li>根据 </li><li>当 节点<code>C</code>是属于要求的<code>分支/标签</code>，存在一条从节点<code>B</code>到节点<code>A</code>的路径，经过节点<code>C</code> （必要性）</li><li>当 节点<code>C</code>不属于要求的<code>分支/标签</code>，对任意一条从节点<code>B</code>到节点<code>A</code>的路径，都不会经过节点<code>C</code> （充分性）</li><li>可得 <code>分支/标签</code>所对应的节点，到<code>根节点</code>的全部路径中途径的<code>所有节点</code>的集合，即为该<code>分支/标签</code>所包含的<code>提交版本</code>集合。</li></ul><h2 class="anchor anchorWithStickyNavbar_mojV" id="算法选择">算法选择<a class="hash-link" href="#算法选择" title="Direct link to heading">​</a></h2><p>我们现在已经完成了数学建模，并且已经为数学建模做了基本的证明。现在，我们终于可以开始在这个数学模型的基础上来设计并实现我们的算法了。</p><p>如果没有做上述基本论证的同学，这里可能会犯一个小错误：那就是它们会误以为，只要计算两个节点之间的最短路径即可。若真是如此的话，<code>SPFA</code>，<code>迪杰斯特拉</code>（Dijkstra），甚至头铁一点儿，来个<code>弗洛伊德</code>（Floyd）都是很容易想到的。当然由于该有向图的所有边长都是1，所以更简单的方法是直接使用<code>广/宽度优先搜索算法（BFS）</code>来计算最短路。</p><p>上述的一系列耳熟能详的算法，或多或少都有成熟的库可以直接使用。但是遗憾的是，如果真的是去算最短路的话，那最终结果恐怕会不尽如人意。</p><p>在<code>DevLake</code>的早期不成熟的版本中，曾经使用过最短路的算法来计算。尽管对于比较简单线性的仓库来说，可以歪打正着的算出结果。但是当仓库的分支和合并变得复杂的时候，最短路所计算的结果往往都会遗漏大量的<code>提交版本</code>。</p><p>因为在刚才我们已经论证过了，这个<code>分支/标签</code>所包含的<code>提交版本</code>集合，是必须要全部路径才行的。只有全部路径，才能满足充分且必要条件。</p><p>也就是说，中间只要漏了一条路径，那就会漏掉一系列的<code>提交版本</code></p><p>要计算这个有向图上的<code>旧节点</code>所代表的<code>分支/标签</code>比<code>新节点</code>所代表的<code>分支/标签</code>缺少了哪些<code>提交版本</code></p><p>实质上就是在计算<code>旧节点</code>到<code>根节点</code>的全部路径所经节点，对比<code>新节点</code>到<code>根节点</code>的全部路径所经节点，缺少了哪些节点。</p><p>如果我们数学建模的时候，把这个有向图建立成一棵树的话</p><p>那么熟悉算法的同学，就可以很自然的使用最近公共祖先（LCA）算法，求出其并集，然后再来计算其对应的缺失的部分。</p><p>但是作为一个有向图来说，树结构的算法是没法直接使用的。所幸的是，我们的这个图，在由合法仓库生成的情况下，必然是一个有向无环图。</p><p>一个有向无环图，也是有自己的最近公共祖先（LCA）算法的。</p><p>只是，这里有两个问题</p><ul><li>我们真的对 最近公共祖先 这个特定的节点感兴趣吗？</li><li>在有多个不同路径的公共祖先的情况下，只求一个最近公共祖先有什么意义呢？</li></ul><p>首先，我们需要明确我们的需求</p><p>我们只是为了计算 </p><ul><li><code>旧节点</code>到<code>根节点</code>的全部路径所经节点，对比<code>新节点</code>到<code>根节点</code>的全部路径所经节点，缺少了哪些节点。</li></ul><p>除此之外的，我们不感兴趣。</p><p>换句话说，我们想知道其公共祖先，但是，不关心它是不是最近的。</p><p>它是近的也好，它是远的也罢，只要是公共祖先，都得抓起来。去求最近公共祖先，在树结构下，可以近似等价于求其全部祖先。因此可以使用该算法。</p><p>但是在有向无环图下，最近公共祖先就是个废物。求出来了又能如何？</p><p>根本上，还是应该去求全部的公共祖先。</p><p>所以我们别无选择，只能用最直接的算法。</p><ul><li>计算出<code>旧节点</code>到<code>根节点</code>的全部路径所经节点</li><li>计算出<code>新节点</code>到<code>根节点</code>的全部路径所经节点</li><li>检查<code>新节点</code>的全部路径所经节点缺少了哪些节点</li></ul><p>如何计算任意节点到<code>根节点</code>的全部路径所经节点？</p><p>在OI上熟练于骗分导论的同学们，应该很自然的就意识到了</p><p><code>深度优先搜索（DFS）</code></p><p>当然，这里补充一下，由于<code>根节点</code>的性质，事实上，无论是从哪个方向出发，无论走那条边，只要是能走的边，最终都会抵达<code>根节点</code></p><p>因此，在上述条件成立的基础上，没有记录路径状态的<code>广/宽度优先搜索（BFS）</code>也是可以使用的。因为在必然能抵达<code>根节点</code>的前提下，可以忽略路径状态，不做路径的可行性判断。</p><p>当然，这一前提，也有利于我们<code>深度优先搜索（DFS）</code>进行优化。</p><p>在我们执行<code>深度优先搜索（DFS）</code>的时候，我们可以将所有访问到的节点，均添加到集合中，而无需等待确认该节点能确实抵达<code>根节点</code>后再进行添加。</p><p>实际上这里在一个问题上我们又会出现了两种分歧。
问题是，如何将一个节点添加到集合中。方案有如下两种。</p><p>染色法：添加到集合中的节点进行染色，未添加到集合中的节点不进行染色。
集合法：使用平衡树算法建立一个集合，将节点添加到该集合中。</p><p>这两种算法各有优劣。</p><ul><li>染色法的优势在于，染色法添加一个元素的时间复杂度是O(1)的，快准狠。相比较而言，集合法添加一个元素的时间复杂度是O(log(n))。</li><li>集合法的优势在于，集合法遍历所有元素的时间复杂度是O(n)的，而染色法下，要遍历所有元素时间复杂度会是O(m)，同时集合法可以通过设计一个优秀的hash算法代替平衡树，来将时间复杂度优化到接近O(1).（这里n表示集合大小，m表示整个图的大小）</li></ul><p>我们这里选择使用集合法。实际上这两种算法都差不多。</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="算法实现">算法实现<a class="hash-link" href="#算法实现" title="Direct link to heading">​</a></h2><ul><li>根据提交建图</li><li>我们对<code>旧节点</code>使用<code>深度优先搜索（DFS）</code>计算出其到<code>根节点</code>的全部路径所经节点，添加到<code>集合A</code>中</li><li>接着，我们对<code>新节点</code>使用<code>深度优先搜索（DFS）</code>计算出其到<code>根节点</code>的全部路径所经节点，添加到<code>集合B</code></li><li>注意，这里有一个优化，这个优化是建立在我们的需求上</li><li>重复一遍我们的需求</li><li>我们只关心<code>目标分支/标签</code>缺少了什么，而并不关心<code>目标分支/标签</code>多出来了什么东西。</li><li>因此当对<code>新节点</code>使用<code>深度优先搜索（DFS）</code>搜索到已经在<code>集合A</code>中的节点时，可以认为该节点已搜索过，无需再次搜索。</li><li>此时的<code>集合B</code>，可以恰好的避开<code>集合A</code>中已有的所有节点，因此，恰好就是我们所需的结果。</li></ul><p>核心的计算代码如下所示：</p><div class="codeBlockContainer_I0IT language-golang theme-code-block"><div class="codeBlockContent_wNvx" style="color:#393A34;background-color:#f6f8fa"><pre tabindex="0" class="prism-code language-golang codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">oldGroup := make(map[string]*CommitNode)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">var dfs func(*CommitNode)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// put all commit sha which can be depth-first-searched by old commit</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">dfs = func(now *CommitNode) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if _, ok = oldGroup[now.Sha]; ok {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    oldGroup[now.Sha] = now</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for _, node := range now.Parent {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        dfs(node)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">dfs(oldCommitNode)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">var newGroup = make(map[string]*CommitNode)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// put all commit sha which can be depth-first-searched by new commit, will stop when find any in either group</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">dfs = func(now *CommitNode) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if _, ok = oldGroup[now.Sha]; ok {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if _, ok = newGroup[now.Sha]; ok {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    newGroup[now.Sha] = now</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    lostSha = append(lostSha, now.Sha)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for _, node := range now.Parent {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        dfs(node)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">dfs(newCommitNode)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><p>这里的lostSha即为我们最终求得的缺失的部分</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="算法执行的演示动画">算法执行的演示动画<a class="hash-link" href="#算法执行的演示动画" title="Direct link to heading">​</a></h2><p>我们用一个简陋的动画来简单的演示一下，上述算法在逻辑上执行的情况。</p><ul><li><code>旧节点</code>为节点<code>8</code></li><li><code>新节点</code>为节点<code>9</code></li></ul><p><img loading="lazy" src="/assets/images/dfs-3464f1398b150e893646c4f21e95ea10.gif" width="868" height="634" class="img_E7b_"></p><p>如上述动画所演示的一般
从节点<code>8</code>开始执行<code>深度优先搜索（DFS）</code>到<code>根节点</code>中止
从节点<code>9</code>开始执行<code>深度优先搜索（DFS）</code>到已经在节点<code>8</code>的集合中的节点为止
此时，在节点<code>9</code>执行<code>深度优先搜索（DFS）</code>过程中被访问到的所有非节点<code>8</code>的节点</p><ul><li>节点<code>3</code></li><li>节点<code>6</code></li><li>节点<code>7</code></li><li>节点<code>9</code> </li></ul><p>它们所对应的<code>提交版本</code>就是我们要求的差集</p><blockquote><p>此时最短路为 <code>9</code> -&gt; <code>7</code> -&gt; <code>5</code> -&gt; <code>8</code>
此时最近公共父节点为 <code>5</code>，到该节点的路径为 <code>9</code> -&gt; <code>7</code> -&gt; <code>5</code>
从上图中也可以直观的看到如果使用最短路算法，或者最近公共父节点算法的情况下，我们是无法得到正确答案的。</p></blockquote><h2 class="anchor anchorWithStickyNavbar_mojV" id="时空复杂度">时空复杂度<a class="hash-link" href="#时空复杂度" title="Direct link to heading">​</a></h2><p>设<code>提交版本</code>的总大小为m，每一组<code>源分支/标签</code>和<code>目标分支/标签</code>的平均大小为n,一共有k组数据</p><p>DFS每访问一个节点，需要执行一次加入集合操作。我们按照我们实际实现中使用的 平衡树算法来计算 时间复杂度为 O(log(n))</p><p>此时我们可以计算得出</p><ul><li>建图的时间复杂度：O(m)</li><li>计算一组<code>源分支/标签</code>和<code>目标分支/标签</code>时间复杂度：O(n<!-- -->*<!-- -->log(n))</li><li>计算所有<code>源分支/标签</code>和<code>目标分支/标签</code>时间复杂度：O(k<!-- -->*<!-- -->n<!-- -->*<!-- -->log(n))</li><li>读取、统计结果时间复杂度：O(k<!-- -->*<!-- -->n)</li><li>总体时间复杂度:O(m + k<!-- -->*<!-- -->n<!-- -->*<!-- -->log(n))</li></ul><hr><ul><li>图的空间复杂度：O(m)</li><li>每组<code>源分支/标签</code>和<code>目标分支/标签</code>集合的空间复杂度：O(n) （非并发情况下，k组数据可共用）</li><li>总体空间复杂度：O(m+n)</li></ul><h2 class="anchor anchorWithStickyNavbar_mojV" id="关键词">关键词<a class="hash-link" href="#关键词" title="Direct link to heading">​</a></h2><ul><li><code>DevLake</code></li><li><code>CalculateCommitsDiff</code></li><li><code>算法</code></li><li><code>数学建模</code></li><li><code>证明逻辑</code></li><li><code>充分条件</code></li><li><code>必要条件</code></li><li><code>图论</code></li><li><code>深度优先搜索（DFS）</code></li><li><code>广/宽度优先搜索（BFS）</code></li><li><code>时间复杂度</code></li><li><code>空间复杂度</code></li><li><code>时空复杂度</code></li></ul>]]></content:encoded>
            <category>devlake</category>
            <category>database</category>
            <category>postgresql</category>
        </item>
        <item>
            <title><![CDATA[Apache DevLake代码库导览]]></title>
            <link>https://devlake.apache.org/blog/apache-devlake-codebase-walkthrough</link>
            <guid>apache-devlake-codebase-walkthrough</guid>
            <pubDate>Mon, 06 Jun 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[Apache DevLake是什么？]]></description>
            <content:encoded><![CDATA[<h3 class="anchor anchorWithStickyNavbar_mojV" id="apache-devlake是什么">Apache DevLake是什么？<a class="hash-link" href="#apache-devlake是什么" title="Direct link to heading">​</a></h3><p>研发数据散落在软件研发生命周期的不同阶段、不同工作流、不同DevOps工具中，且标准化程度低，导致效能数据难以留存、汇集并转化为有效洞见。为了解决这一痛点，<a href="https://github.com/apache/incubator-devlake" target="_blank" rel="noopener noreferrer">Apache DevLake</a> 应运而生。Apache DevLake是一款开源的研发数据平台，它通过提供自动化、一站式的数据收集、分析以及可视化能力，帮助研发团队更好地理解开发过程，挖掘关键瓶颈与提效机会。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="apache-devlake架构概述">Apache DevLake架构概述<a class="hash-link" href="#apache-devlake架构概述" title="Direct link to heading">​</a></h3><p><img loading="lazy" alt="img" src="/assets/images/Architecture_Diagram-f52640e8c40d052f526ed8283e2833e5.png" width="1262" height="641" class="img_E7b_"></p><center>Apache DevLake 架构图</center><br><ul><li>Config UI: 人如其名，配置的可视化，其主要承载Apache DevLake的配置工作。通过Config UI，用户可以建立数据源连接，并实现数据的收集范围，部分数据的转换规则，以及收集频率等任务。</li><li>Api Sever：Apache DevLake的Api接口，是前端调用后端数据的通道。</li><li>Runner：Apache DevLake运行的底层支撑机制。</li><li>Plugins：具体执行的插件业务，主要承载Apache DevLake的后端数据收集、扩展和转换的工作。除dbt插件外的插件产出Apache DevLake的预置数据，预置数据主要包括三层；<ul><li>raw layer：负责储存最原始的api response json。</li><li>tool layer：根据raw layer提取出此插件所需的数据。</li><li>domain layer：根据tool layer层抽象出共性的数据，这些数据会被使用在Grafana图表中，用于多种研发指标的展示。</li></ul></li><li>RDBS: 关系型数据库。目前Apache DavLake支持MySQL和PostgreSQL，后期还会继续支持更多的数据库。</li><li>Grafana Dashboards: 其主要承载Apache DevLake的前端展示工作。根据Apache DevLake收集的数据，通过sql语句来生成团队需要的交付效率、质量、成本、能力等各种研发效能指标。</li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="目录结构tree">目录结构Tree<a class="hash-link" href="#目录结构tree" title="Direct link to heading">​</a></h3><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx" style="color:#393A34;background-color:#f6f8fa"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">├── api</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; ├── blueprints</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; ├── docs</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; ├── domainlayer</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; ├── ping</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; ├── pipelines</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; ├── push</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; ├── shared</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; ├── task</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; └── version</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">├── config</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">├── config-ui</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">├── devops</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; └── lake-builder</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">├── e2e</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">├── errors</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">├── grafana</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; ├── _archive</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; ├── dashboards</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; ├── img</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; └── provisioning</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp;     ├── dashboards</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp;     └── datasources</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">├── img</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">├── logger</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">├── logs</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">├── migration</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">├── models</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; ├── common</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; ├── domainlayer</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── code</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── crossdomain</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── devops</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── didgen</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── ticket</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; │&nbsp;&nbsp; └── user</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; └── migrationscripts</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp;     └── archived</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">├── plugins</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; ├── ae</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── api</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── models</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── migrationscripts</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp;     └── archived</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; │&nbsp;&nbsp; └── tasks</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; ├── core</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; ├── dbt</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; │&nbsp;&nbsp; └── tasks</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; ├── feishu</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── apimodels</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── models</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── migrationscripts</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp;     └── archived</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; │&nbsp;&nbsp; └── tasks</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; ├── gitextractor</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── models</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── parser</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── store</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; │&nbsp;&nbsp; └── tasks</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; ├── github</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── api</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── models</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── migrationscripts</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp;     └── archived</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── tasks</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; │&nbsp;&nbsp; └── utils</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; ├── gitlab</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── api</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── e2e</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── tables</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── impl</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── models</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── migrationscripts</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp;     └── archived</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; │&nbsp;&nbsp; └── tasks</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; ├── helper</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; ├── jenkins</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── api</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── models</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── migrationscripts</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp;     └── archived</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; │&nbsp;&nbsp; └── tasks</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; ├── jira</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── api</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── models</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── migrationscripts</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp;     └── archived</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; │&nbsp;&nbsp; └── tasks</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; │&nbsp;&nbsp;     └── apiv2models</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; ├── refdiff</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── tasks</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; │&nbsp;&nbsp; └── utils</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; └── tapd</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp;     ├── api</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp;     ├── models</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp;     │&nbsp;&nbsp; └── migrationscripts</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp;     │&nbsp;&nbsp;     └── archived</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp;     └── tasks</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">├── releases</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; ├── lake-v0.10.0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; ├── lake-v0.10.0-beta1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; ├── lake-v0.10.1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; ├── lake-v0.7.0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; ├── lake-v0.8.0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; └── lake-v0.9.0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">├── runner</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">├── scripts</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">├── services</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">├── test</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; ├── api</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; │&nbsp;&nbsp; └── task</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│&nbsp;&nbsp; └── example</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">├── testhelper</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">├── utils</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">├── version</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">├── worker</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">├── Dockerfile</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">├── docker-compose.yml</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">├── docker-compose-temporal.yml</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">├── k8s-deploy.yaml</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">├── Makefile</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">└── .env.exemple</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="目录导览">目录导览<a class="hash-link" href="#目录导览" title="Direct link to heading">​</a></h3><ul><li>后端部分：<ul><li>config：对.env配置文件的读、写以及修改的操作。</li><li>logger：log日志的level、format等设置。</li><li>errors：Error的定义。</li><li>utils：工具包，它包含一些基础通用的函数。</li><li>runner：提供基础执行服务，包括数据库，cmd，pipelines，tasks以及加载编译后的插件等基础服务。</li><li>models：定义框架级别的实体。<ul><li>common：基础struct定义。</li><li><a href="https://devlake.apache.org/docs/DataModels/DevLakeDomainLayerSchema" target="_blank" rel="noopener noreferrer">domainlayer</a>：领域层是来自不同工具数据的通用抽象。<ul><li>ticket：Issue Tracking，即问题跟踪领域。</li><li>code：包括Source Code源代码关联领域。以及Code Review代码审查领域。</li><li>devops：CI/CD，即持续集成、持续交付和持续部署领域。</li><li>crossdomain：跨域实体，这些实体用于关联不同领域之间的实体，这是建立全方面分析的基础。</li><li>user：对用户的抽象领域，user也属于crossdomain范畴。</li></ul></li><li>migrationscripts：初始化并更新数据库。</li></ul></li><li>plugins：<ul><li>core：插件通用接口的定义以及管理。</li><li>helper：插件通用工具的集合，提供插件所需要的辅助类，如api收集，数据ETL，时间处理等。<ul><li>网络请求Api Client工具。</li><li>收集数据Collector辅助类，我们基于api相同的处理模式，统一了并发，限速以及重试等功能，最终实现了一套通用的框架，极大地减少了开发和维护成本。</li><li>提取数据Extractor辅助类，同时也内建了批量处理机制。</li><li>转换数据Convertor辅助类。</li><li>数据库处理工具。</li><li>时间处理工具。</li><li>函数工具。</li></ul></li><li>ae：分析引擎，用于导入merico ae分析引擎的数据。</li><li>feishu：收集飞书数据，目前主要是获取一段时间内组织内会议使用的top用户列表的数据。</li><li>github：收集Github数据并计算相关指标。（其他的大部分插件的目录结构和实现功能和github大同小异，这里以github为例来介绍）。<ul><li>github.go：github启动入口。</li><li>tasks：具体执行的4类任务。<ul><li>*_collector.go：收集数据到raw layer层。</li><li>*_extractor.go：提取所需的数据到tool layer层。</li><li>*_convertor.go：转换所需的数据到domain layer层。</li><li>*_enricher.go：domain layer层更进一步的数据计算转换。</li></ul></li><li>models：定义github对应实体entity。</li><li>api：api接口。</li><li>utils：github提取的一些基本通用函数。</li></ul></li><li>gitextractor：git数据提取工具，该插件可以从远端或本地git仓库提取commit和reference信息，并保存到数据库或csv文件。用来代替github插件收集commit信息以减少api请求的数量，提高收集速度。</li><li>refdiff：在分析开发工作产生代码量时，经常需要知道两个版本之间的diff。本插件基于数据库中存储的commits父子关系信息，提供了计算ref(branch/tag)之间相差commits列表的能力。</li><li>gitlab：收集Gitlab数据并计算相关指标。</li><li>jenkins：收集jenkins的build和job相关指标。</li><li>jira：收集jira数据并计算相关指标。</li><li>tapd：收集tapd数据并计算相关指标。</li><li>dbt：(data build tool)是一款流行的开源数据转换工具，能够通过SQL实现数据转化，将命令转化为表或者视图，提升数据分析师的工作效率。Apache DevLake增加了dbt插件，用于数据定制的需要。</li></ul></li><li>services：创建、管理Apache DevLake各种服务，包含notifications、blueprints、pipelines、tasks、plugins等。</li><li>api：使用Gin框架搭建的一个通用Apache DevLake API服务。</li></ul></li><li>前端部分：<ul><li>congfig-ui：主要是Apache DevLake的插件配置信息的可视化。<a href="https://devlake.apache.org/docs/Glossary" target="_blank" rel="noopener noreferrer">一些术语的解释</a><ul><li>常规模式 <ul><li>blueprints的配置。</li><li>data connections的配置。</li><li>transformation rules的配置。</li></ul></li><li>高级模式：主要是通过json的方式来请求api，可选择对应的插件，对应的subtasks，以及插件所需要的其他信息。</li></ul></li><li>Grafana：其主要承载Apache DevLake的前端展示工作。根据收集的数据，通过sql语句来生成团队需要的各种数据。目前sql主要用domain layer层的表来实现通用数据展示需求。</li></ul></li><li>migration：数据库迁移工具。<ul><li>migration：数据库迁移工具migration的具体实现。</li><li>models/migrationscripts：domian layer层的数据库迁移脚本。</li><li>plugins/xxx/models/migrationscripts：插件的数据库迁移脚本。主要是<em>raw</em>和<em>tool</em>开头的数据库的迁移。</li></ul></li><li>测试部分：<ul><li>testhelper和plugins下的*_test.go文件：即单元测试，属于白盒测试范畴。针对目标对象自身的逻辑，执行路径的正确性进行测试，如果目标对象有依赖其它资源或对够用，采用注入或者 mock 等方式进行模拟，可以比较方便地制造一些难以复现的极端情况。</li><li>test：集成测试，灰盒测试范畴。在单元测试的基础上，将所有模块按照设计要求（如根据结构图）组装成为子系统或系统，进行集成测试。</li><li>e2e： 端到端测试，属于黑盒测试范畴。相对于单元测试更注重于目标自身，e2e更重视目标与系统其它部分互动的整体正确性，相对于单元测试着重逻辑测试，e2e侧重于输出结果的正确性。</li></ul></li><li>编译，发布部分：<ul><li>devops/lake-builder： mericodev/lake-builder的docker构建。</li><li>Dockerfile：主要用于构建devlake镜像。</li><li>docker-compose.yml：是用于定义和运行多容器Docker应用程序的工具，用户可以使用YML文件来配置Apache DevLake所需要的服务组件。</li><li>docker-compose-temporal.yml：Temporal是一个微服务编排平台，以分布式的模式来部署Apache DevLake，目前处于试验阶段，仅供参考。</li><li>worker：Temporal分布式部署形式中的worker实现，目前处于试验阶段，仅供参考。</li><li>k8s-deploy.yaml：Kubernetes是一个可移植、可扩展的开源平台，用于管理容器化的工作负载和服务，可促进声明式配置和自动化。目前Apache DevLake已支持在k8s集群上部署。</li><li>Makefile：是一个工程文件的编译规则，描述了整个工程的编译和链接等规则。</li><li>releases：Apache DevLake历史release版本的配置文件，包括docker-compose.yml和env.example。</li><li>scripts：shell脚本，包括编译plugins脚本。</li></ul></li><li>其他：<ul><li>img：logo、社区微信二维码等图像信息。</li><li>version：实现版本显示的支持，在正式的镜像中会显示对应release的版本。</li><li>.env.exemple：配置文件实例，包括DB URL, LOG以及各插件的配置示例信息。</li></ul></li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="如何联系我们">如何联系我们<a class="hash-link" href="#如何联系我们" title="Direct link to heading">​</a></h3><ul><li>Github地址：<a href="https://github.com/apache/incubator-devlake" target="_blank" rel="noopener noreferrer">https://github.com/apache/incubator-devlake</a></li><li>官网地址：<a href="https://devlake.apache.org/" target="_blank" rel="noopener noreferrer">https://devlake.apache.org/</a></li><li><a href="https://join.slack.com/t/devlake-io/shared_invite/zt-18uayb6ut-cHOjiYcBwERQ8VVPZ9cQQw" target="_blank" rel="noopener noreferrer">Slack</a>: 通过Slack联系</li><li>微信联系:<br><img loading="lazy" alt="img" src="data:image/png;base64,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" width="300" height="300" class="img_E7b_"></li></ul>]]></content:encoded>
            <category>devlake</category>
            <category>codebase</category>
        </item>
        <item>
            <title><![CDATA[如何贡献issues]]></title>
            <link>https://devlake.apache.org/blog/how-to-contribute-to-issues</link>
            <guid>how-to-contribute-to-issues</guid>
            <pubDate>Fri, 20 May 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[上周(2022-05-12)，我们以先到先得的方式为大家列出了两个"good first issue"。]]></description>
            <content:encoded><![CDATA[<p>上周(2022-05-12)，我们以先到先得的方式为大家列出了两个"good first issue"。
这很有趣，它们几乎立刻就被拿走了......
但对于那些有兴趣但没有得到的人来说可能就不那么有趣了。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="所以">所以...<a class="hash-link" href="#所以" title="Direct link to heading">​</a></h3><p>我们决定，不再有竞争，你可以从我们的github issue pages中挑选你喜欢的issue。如果没有了，甚至可以创建你自己的。
我们毕竟是社区！</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="怎么做呢这很简单">怎么做呢？这很简单!<a class="hash-link" href="#怎么做呢这很简单" title="Direct link to heading">​</a></h3><p>进入我们的<a href="https://github.com/apache/incubator-devlake/issues?q=is%3Aopen+is%3Aissue+label%3A%22good+first+issue%22" target="_blank" rel="noopener noreferrer">问题页面</a>，然后点击这里。我们所有的Good First Issue都列在这里!
<img loading="lazy" alt="good first issue" src="/assets/images/issue_page_screenshot-4aa3f48811d5bc6aa1a36ce71727344c.png" width="1320" height="266" class="img_E7b_"></p><ul><li><p>首先，寻找现有的issues，找到一个你喜欢的。
你可以通过评论"I'll take it!"来预订它。
接下来你可以写一份“攻略”，以展示你对问题的理解和你将采取什么样的步骤来解决这个issue，然后开始Coding。</p></li><li><p>如果没有GFI了怎么办？创造你自己的issue! 现在，通过查看我们的代码库。
你肯定能发现很多问题，比如文档、单元测试，甚至是错字。
把你觉得不对的地方提出来，我们会验证它是否必要，
然后你就可以开始Coding了。</p></li><li><p>最后，你可能会问，我为什么要费尽心思为你写代码？
不不不，你不是为我们写代码，你是为社区里的每个人写代码，你是为自己写代码。
为了提高你的技能，为了学习如何与他人合作。而对于那些做出重大贡献的人，
我们为您提供一个Apache Committer的席位，甚至是PPMC！</p></li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="就这些了有任何问题请随时提出编码快乐">就这些了，有任何问题请随时提出。编码快乐！<a class="hash-link" href="#就这些了有任何问题请随时提出编码快乐" title="Direct link to heading">​</a></h3>]]></content:encoded>
            <category>devlake</category>
            <category>apache</category>
        </item>
        <item>
            <title><![CDATA[Apache Incubator Welcomes DevLake, A Dev-Data Platform Serving Developers]]></title>
            <link>https://devlake.apache.org/blog/apache-welcomes-devlake</link>
            <guid>apache-welcomes-devlake</guid>
            <pubDate>Wed, 18 May 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[We are excited to share today that the Apache Software Foundation (ASF) voted to make DevLake an officially supported project of the Apache Incubator.]]></description>
            <content:encoded><![CDATA[<p>We are excited to share today that the Apache Software Foundation (ASF) voted to make DevLake an officially supported project of the Apache Incubator.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="what-is-devlake">What is DevLake?<a class="hash-link" href="#what-is-devlake" title="Direct link to heading">​</a></h3><p>Launched in December of 2021, <a href="https://github.com/apache/incubator-devlake" target="_blank" rel="noopener noreferrer">Apache DevLake</a> is an open-source dev data platform that ingests, analyzes, and visualizes the fragmented data in developer tools. </p><p>Software development is complex, requiring many tools and processes, and as a result creates a storm of data scattered across tools in many formats. This makes it difficult to organize, query, and make sense of. We built Apache DevLake, to make it easy to make sense of this rich data and to translate it into actionable insights.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="apache-devlakes-key-features">Apache DevLake's key features:<a class="hash-link" href="#apache-devlakes-key-features" title="Direct link to heading">​</a></h3><ul><li>DevOps data collection across software development lifecycle (SDLC) to connect data islands</li><li>Standardized data models with out-of-the-box metrics and customizable dashboards</li><li>Flexible plugin system for user-defined data integration and transformation</li></ul><p>Below is the architecture of Apache DevLake:
<img loading="lazy" alt="architecture" src="/assets/images/0.11-architecture-diagram-f422e47efad0b84f72eb3bc51c7d1f1b.jpg" width="2143" height="1182" class="img_E7b_"></p><h3 class="anchor anchorWithStickyNavbar_mojV" id="why-join-apache-incubator">Why join Apache Incubator?<a class="hash-link" href="#why-join-apache-incubator" title="Direct link to heading">​</a></h3><p>First and foremost, we firmly believe in Apache's principle of "Community over Code" and <a href="https://www.apache.org/theapacheway/index.html" target="_blank" rel="noopener noreferrer">"The Apache Way"</a>. We look forward to building a vibrant, inclusive, and diverse community under the guidance of our mentors through the incubator journey.</p><p>We also feel that the Apache community has one of the strongest ecosystems when it comes to data-oriented open-source projects. </p><p>Last and not least, the support and enthusiasm of the Apache community and mentors made it clear to us that this would be a place where we can truly evolve and nurture Apache DevLake.</p><p>In the months leading up to DevLake's acceptance, our mentors provided guidance and suggestions instrumental to making this important moment a reality. We want to take this opportunity to thank and acknowledge them: </p><ul><li><p><strong><a href="https://github.com/WillemJiang" target="_blank" rel="noopener noreferrer">Willem Ning Jiang</a></strong>: Apache DevLake Champion; ASF Member &amp; Board Director</p></li><li><p><strong><a href="https://github.com/terrymanu" target="_blank" rel="noopener noreferrer">Liang Zhang</a></strong>: Founder &amp; CEO of SphereEx; ASF Member, Founder &amp; PMC Chair of Apache ShardingSphere</p></li><li><p><strong><a href="https://github.com/dailidong" target="_blank" rel="noopener noreferrer">Lidong Dai</a></strong>: ASF Member; Apache DolphinScheduler PMC Chair</p></li><li><p><strong><a href="https://github.com/sijie" target="_blank" rel="noopener noreferrer">Sijie Guo</a></strong>: ASF Member, PMC member of Apache Pulsar; Founder &amp; CEO of StreamNative</p></li><li><p><strong><a href="https://github.com/felixcheung" target="_blank" rel="noopener noreferrer">Felix Cheung</a></strong>: ASF Member, PMC on Spark, Superset, Yunikorn, Zeppelin, Pinot, and Incubator. SVP of Engineering at SafeGraph.</p></li><li><p><strong><a href="https://github.com/jbonofre" target="_blank" rel="noopener noreferrer">Jean-Baptiste Onofré</a></strong>: ASF Member, Karaf PMC Chair, PMC on ActiveMQ, Archiva, Aries, Beam, Brooklyn, Camel, Carbondata, Felix, Incubator, and <a href="http://people.apache.org/committer-index.html" target="_blank" rel="noopener noreferrer">many more</a>.</p></li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="apache-devlake-future-roadmap">Apache DevLake Future Roadmap<a class="hash-link" href="#apache-devlake-future-roadmap" title="Direct link to heading">​</a></h3><ul><li>Enhance system scalability and performance in large-scale data scenarios.</li><li>Integrate more data sources and tools (JIRA, GitHub, GitLab, and Jenkins are already supported.)</li><li>Enable support for OLAP databases, providing users with more choices.</li><li>Provide more scenario-specific, out-of-the-box dashboards and templates reflecting best practices and well-known methodologies to improve usability.</li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="join-us">Join us!<a class="hash-link" href="#join-us" title="Direct link to heading">​</a></h3><p>We invite developers and those passionate about data-driven engineering to 'dive into the lake' with us, and welcome contributions of all kinds.
Join us on Slack and at our weekly open source community meetups🥳</p><p><strong>Apache DevLake (Incubating) Links:</strong></p><ul><li>GitHub:  <a href="https://github.com/apache/incubator-devlake" target="_blank" rel="noopener noreferrer">https://github.com/apache/incubator-devlake</a></li><li>Official Website: <a href="https://devlake.apache.org/" target="_blank" rel="noopener noreferrer">https://devlake.apache.org/</a></li><li>Slack:   <a href="https://join.slack.com/t/devlake-io/shared_invite/zt-18uayb6ut-cHOjiYcBwERQ8VVPZ9cQQw" target="_blank" rel="noopener noreferrer">https://join.slack.com/t/devlake-io/shared_invite/zt-18uayb6ut-cHOjiYcBwERQ8VVPZ9cQQw</a></li><li>Podling Website：<a href="https://incubator.apache.org/projects/devlake.html" target="_blank" rel="noopener noreferrer">https://incubator.apache.org/projects/devlake.html</a></li></ul>]]></content:encoded>
            <category>Devlake</category>
            <category>Apache</category>
        </item>
        <item>
            <title><![CDATA[Apache DevLake是怎么跑起来的]]></title>
            <link>https://devlake.apache.org/blog/how-apache-devlake-runs</link>
            <guid>how-apache-devlake-runs</guid>
            <pubDate>Wed, 18 May 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[Apache DevLake 是一个DevOps数据收集和整合工具，通过 Grafana 为开发团队呈现出不同阶段的数据，让团队能够以数据为驱动改进开发流程。]]></description>
            <content:encoded><![CDATA[<p><a href="https://github.com/apache/incubator-devlake" target="_blank" rel="noopener noreferrer">Apache DevLake</a> 是一个DevOps数据收集和整合工具，通过 Grafana 为开发团队呈现出不同阶段的数据，让团队能够以数据为驱动改进开发流程。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="apache-devlake-架构概述">Apache DevLake 架构概述<a class="hash-link" href="#apache-devlake-架构概述" title="Direct link to heading">​</a></h3><ul><li>左边是<a href="https://devlake.apache.org/docs/DataModels/DataSupport" target="_blank" rel="noopener noreferrer">可集成的DevOps数据插件</a>，目前已有的插件包括 Github，Gitlab，JIRA，Jenkins，Tapd，Feishu 以及思码逸主打的代码分析引擎</li><li>中间是主体框架，通过主体框架运行插件中的子任务，完成数据的收集，扩展，并转换到领域层，用户可以通过 config-ui 或者 api 调用的形式来触发任务</li><li>RMDBS 目前支持 Mysql 和 PostgreSQL，后期还会继续支持更多的数据库</li><li>Grafana 可以通过sql语句生成团队需要的各种数据</li></ul><p><img loading="lazy" alt="Generated" src="/assets/images/Aspose.Words.093a76ac-457b-4498-a472-7dbea580bca9.001-9fe996eee294ce1843bc3f126a1a7b89.png" width="567" height="310" class="img_E7b_"></p><blockquote><p>接下来我们就详细聊一聊系统是怎么跑起来的。</p></blockquote><h3 class="anchor anchorWithStickyNavbar_mojV" id="系统启动">系统启动<a class="hash-link" href="#系统启动" title="Direct link to heading">​</a></h3><p>在我们的 golang 程序启动之前，首先会自动调用各个 package 的 init() 方法，我们主要看看services 包的载入，下面的代码有详细注释：</p><div class="codeBlockContainer_I0IT language-go theme-code-block"><div class="codeBlockContent_wNvx" style="color:#393A34;background-color:#f6f8fa"><pre tabindex="0" class="prism-code language-go codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">func</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">init</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">var</span><span class="token plain"> err </span><span class="token builtin">error</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic">// 获取配置信息</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cfg </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> config</span><span class="token punctuation" style="color:#393A34">.</span><span class="token function" style="color:#d73a49">GetConfig</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic">// 获取到数据库</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">db</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> err </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> runner</span><span class="token punctuation" style="color:#393A34">.</span><span class="token function" style="color:#d73a49">NewGormDb</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">cfg</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> logger</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">Global</span><span class="token punctuation" style="color:#393A34">.</span><span class="token function" style="color:#d73a49">Nested</span><span class="token punctuation" style="color:#393A34">(</span><span class="token string" style="color:#e3116c">"db"</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic">// 配置时区</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">location </span><span class="token operator" style="color:#393A34">:=</span><span class="token plain"> cron</span><span class="token punctuation" style="color:#393A34">.</span><span class="token function" style="color:#d73a49">WithLocation</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">time</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">UTC</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic">// 创建定时任务管理器</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cronManager </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> cron</span><span class="token punctuation" style="color:#393A34">.</span><span class="token function" style="color:#d73a49">New</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">location</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">if</span><span class="token plain"> err </span><span class="token operator" style="color:#393A34">!=</span><span class="token plain"> </span><span class="token boolean" style="color:#36acaa">nil</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token function" style="color:#d73a49">panic</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">err</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic">// 初始化数据迁移</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">migration</span><span class="token punctuation" style="color:#393A34">.</span><span class="token function" style="color:#d73a49">Init</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">db</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic">// 注册框架的数据迁移脚本</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">migrationscripts</span><span class="token punctuation" style="color:#393A34">.</span><span class="token function" style="color:#d73a49">RegisterAll</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic">// 载入插件，从cfg.GetString("PLUGIN_DIR")获取到的文件夹中载入所有.so文件，在LoadPlugins方法中，具体来讲，通过调用runner.LoadPlugins将pluginName:PluginMeta键值对存入到core.plugins中</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">err </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> runner</span><span class="token punctuation" style="color:#393A34">.</span><span class="token function" style="color:#d73a49">LoadPlugins</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cfg</span><span class="token punctuation" style="color:#393A34">.</span><span class="token function" style="color:#d73a49">GetString</span><span class="token punctuation" style="color:#393A34">(</span><span class="token string" style="color:#e3116c">"PLUGIN_DIR"</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cfg</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">logger</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">Global</span><span class="token punctuation" style="color:#393A34">.</span><span class="token function" style="color:#d73a49">Nested</span><span class="token punctuation" style="color:#393A34">(</span><span class="token string" style="color:#e3116c">"plugin"</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">db</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">if</span><span class="token plain"> err </span><span class="token operator" style="color:#393A34">!=</span><span class="token plain"> </span><span class="token boolean" style="color:#36acaa">nil</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token function" style="color:#d73a49">panic</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">err</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic">// 执行数据迁移脚本，完成数据库框架层各个表的初始化</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">err </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> migration</span><span class="token punctuation" style="color:#393A34">.</span><span class="token function" style="color:#d73a49">Execute</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">context</span><span class="token punctuation" style="color:#393A34">.</span><span class="token function" style="color:#d73a49">Background</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">if</span><span class="token plain"> err </span><span class="token operator" style="color:#393A34">!=</span><span class="token plain"> </span><span class="token boolean" style="color:#36acaa">nil</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token function" style="color:#d73a49">panic</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">err</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic">// call service init</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token function" style="color:#d73a49">pipelineServiceInit</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="devlake的任务执行原理">DevLake的任务执行原理<a class="hash-link" href="#devlake的任务执行原理" title="Direct link to heading">​</a></h3><p><strong>Pipeline的运行流程</strong></p><p>在讲解Pipeline流程之前，我们需要先解释一下<a href="https://devlake.apache.org/docs/Glossary#blueprints" target="_blank" rel="noopener noreferrer">Blueprint</a>。</p><p>Blueprint是一个定时任务，包含了需要执行的子任务以及执行计划。Blueprint 的每一次执行记录是一条Historical Run（也称为 Pipeline），代表 DevLake 一次触发，通过一个或多个插件，完成了一个或多个数据收集转换的任务。</p><p><img loading="lazy" alt="Generated" src="/assets/images/Aspose.Words.093a76ac-457b-4498-a472-7dbea580bca9.002-40065677c2b00df89eeaac1d9512f286.png" width="567" height="263" class="img_E7b_"></p><p>以下是 Pipeline 运行流程图：</p><p><img loading="lazy" alt="Generated" src="/assets/images/Aspose.Words.093a76ac-457b-4498-a472-7dbea580bca9.003-d07631a740cb5b056d15a35627afef80.png" width="344" height="515" class="img_E7b_"></p><p>一个pipeline包含一个二维数组tasks，主要是为了保证一系列任务按预设顺序执行。如果下图中的 Stage3 的插件需要依赖其他插件准备数据（例如 refdiff 的运行需要依赖 gitextractor 和 github，数据源与插件的更多信息请看<a href="https://devlake.apache.org/docs/DataModels/DataSupport" target="_blank" rel="noopener noreferrer">文档</a>），那么 Stage 3 开始执行时，需要保证其依赖项已在 Stage1 和 Stage2 执行完成：</p><p><img loading="lazy" alt="Generated" src="/assets/images/Aspose.Words.093a76ac-457b-4498-a472-7dbea580bca9.004-a6a550c4f00b232abc7b28e30738be09.png" width="567" height="238" class="img_E7b_"></p><p><strong>Task的运行流程</strong></p><p>在stage1，stage2，stage3中的各插件任务都是并行执行：</p><p><img loading="lazy" alt="Generated" src="/assets/images/Aspose.Words.093a76ac-457b-4498-a472-7dbea580bca9.005-4d14031484d1272b4be8d7ff2f08d2a2.png" width="304" height="501" class="img_E7b_"></p><p><strong>接下来就是顺序执行插件中的子任务</strong></p><p><img loading="lazy" alt="Generated" src="/assets/images/Aspose.Words.093a76ac-457b-4498-a472-7dbea580bca9.006-83ed245c2c8d805aca908814f0f0f5f9.png" width="331" height="617" class="img_E7b_"></p><ol><li>RunTask 之前的工作都是在准备 RunTask 方法需要的参数，比如 logger，db，context 等等。</li><li>RunTask 方法中主要是对数据库中的tasks进行状态更新，同时，准备运行插件任务的 options（把从 config-ui 传过来的 json 转成 map 传到 RunPluginTask 中）</li><li>RunPluginTask 首先通过 core.GetPlugin(pluginName) 获取到对应 <a href="#pm">PluginMeta</a>，然后通过 PluginMeta 获取到 <a href="#pt">PluginTask</a>，再执行 RunPluginSubTasks</li></ol><p><strong>每一个插件子任务的运行流程（涉及到的 interface 及 func 会在<a href="#DevLake%E4%B8%AD%E7%9A%84%E9%87%8D%E8%A6%81%E6%8E%A5%E5%8F%A3">下一节</a>详细阐述）</strong></p><p><img loading="lazy" alt="Generated" src="/assets/images/Aspose.Words.093a76ac-457b-4498-a472-7dbea580bca9.007-09a5f7c401dfb5a557b10c3870d103fe.png" width="567" height="214" class="img_E7b_"></p><ol><li>通过调用SubTaskMetas()获取到所有插件所有的可用子任务<a href="#stm">subtaskMeta</a></li><li>通过<code>options["tasks"]</code>以及subtaskMeta组建需要执行的子任务集合subtaskMetas</li><li>计算总共多少个子任务</li><li>通过<code>helper.NewDefaultTaskContext</code>构建<a href="#tc">taskCtx</a></li><li>调用<code>pluginTask.PrepareTaskData</code>构建<a href="#td">taskData</a>，</li><li>接下来迭代subtaskMetas里面的所有子任务<ol><li>通过<code>taskCtx.SubTaskContext(subtaskMeta.Name)</code>获取到子任务的<a href="#sc">subtaskCtx</a></li><li>执行<a href="#step"><code>subtaskMeta.EntryPoint(subtaskCtx)</code></a></li></ol></li></ol><h3 class="anchor anchorWithStickyNavbar_mojV" id="devlake中的重要接口">DevLake中的重要接口<a class="hash-link" href="#devlake中的重要接口" title="Direct link to heading">​</a></h3><ol><li><a id="pm">PluginMeta</a>: 包含了插件最基本的两个方法，所有插件都需要实现，系统启动的时候存在core.plugins中，在执行插件任务的时候通过core.GetPlugin获取</li></ol><div class="codeBlockContainer_I0IT language-go theme-code-block"><div class="codeBlockContent_wNvx" style="color:#393A34;background-color:#f6f8fa"><pre tabindex="0" class="prism-code language-go codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">type</span><span class="token plain"> PluginMeta </span><span class="token keyword" style="color:#00009f">interface</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   </span><span class="token function" style="color:#d73a49">Description</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token builtin">string</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   </span><span class="token comment" style="color:#999988;font-style:italic">//PkgPath information will be lost when compiled as plugin(.so), this func will return that info</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   </span><span class="token function" style="color:#d73a49">RootPkgPath</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token builtin">string</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><ol start="2"><li><a id="pt">PluginTask</a>: 通过PluginMeta获取，插件实现这个方法之后，Framework就能直接运行子任务，而不是扔给插件自己去执行，最大的好处就是插件的子任务实现更加简单，在插件运行当中，我们也可以更容易的去干涉（比如增加日志等等）</li></ol><div class="codeBlockContainer_I0IT language-go theme-code-block"><div class="codeBlockContent_wNvx" style="color:#393A34;background-color:#f6f8fa"><pre tabindex="0" class="prism-code language-go codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">type</span><span class="token plain"> PluginTask </span><span class="token keyword" style="color:#00009f">interface</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   </span><span class="token comment" style="color:#999988;font-style:italic">// return all available subtasks, framework will run them for you in order</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   </span><span class="token function" style="color:#d73a49">SubTaskMetas</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">[</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain">SubTaskMeta</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   </span><span class="token comment" style="color:#999988;font-style:italic">// based on task context and user input options, return data that shared among all subtasks</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   </span><span class="token function" style="color:#d73a49">PrepareTaskData</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">taskCtx TaskContext</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> options </span><span class="token keyword" style="color:#00009f">map</span><span class="token punctuation" style="color:#393A34">[</span><span class="token builtin">string</span><span class="token punctuation" style="color:#393A34">]</span><span class="token keyword" style="color:#00009f">interface</span><span class="token punctuation" style="color:#393A34">{</span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token keyword" style="color:#00009f">interface</span><span class="token punctuation" style="color:#393A34">{</span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token builtin">error</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><ol start="3"><li>每个插件还有一个<a id="td">taskData</a>，里面包含了配置选项，apiClient以及一些插件其它属性（比如github有Repo信息）</li><li><a id="stm">SubTaskMeta</a>: 一个子任务的元数据，每个子任务都会定义一个SubTaskMeta</li></ol><div class="codeBlockContainer_I0IT language-go theme-code-block"><div class="codeBlockContent_wNvx" style="color:#393A34;background-color:#f6f8fa"><pre tabindex="0" class="prism-code language-go codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">var</span><span class="token plain"> CollectMeetingTopUserItemMeta </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> core</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">SubTaskMeta</span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   Name</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">"collectMeetingTopUserItem"</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   EntryPoint</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> CollectMeetingTopUserItem</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   EnabledByDefault</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> </span><span class="token boolean" style="color:#36acaa">true</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   Description</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">"Collect top user meeting data from Feishu api"</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><ol start="5"><li><a id="ec">ExecContext</a>: 定义了执行(子)任务需要的所有资源</li><li><a id="stc">SubTaskContext</a>: 定义了执行子任务所需要的资源（包含了ExecContext）</li><li><a id="tc">TaskContext</a>: 定义了执行插件任务所需要的资源（包含了ExecContext）。与SubTaskContext的区别在于SubTaskContext中的TaskContext()方法可以返回TaskContext，而TaskContext中的方法SubTaskContext(subtask string)方法可以返回SubTaskContext，子任务隶属于插件任务，所以把这两个Context进行了区分</li><li><a id="step">SubTaskEntryPoint</a>: 所有的插件子任务都需要实现这个函数，这样才能由框架层统一协调安排</li></ol><h3 class="anchor anchorWithStickyNavbar_mojV" id="后续">后续<a class="hash-link" href="#后续" title="Direct link to heading">​</a></h3><p>这篇文章介绍了 DevLake 的架构以及运行流程，还有三个核心 api<!-- -->_<!-- -->collector、api<!-- -->_<!-- -->extractor 和 data<!-- -->_<!-- -->convertor 将会在下一篇文章进行剖析。</p>]]></content:encoded>
            <category>devlake</category>
            <category>apache</category>
        </item>
        <item>
            <title><![CDATA[使用ants引发的死锁]]></title>
            <link>https://devlake.apache.org/blog/deadlock-caused-by-using-ants</link>
            <guid>deadlock-caused-by-using-ants</guid>
            <pubDate>Sat, 30 Apr 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[1. 背景]]></description>
            <content:encoded><![CDATA[<h3 class="anchor anchorWithStickyNavbar_mojV" id="1-背景">1. 背景<a class="hash-link" href="#1-背景" title="Direct link to heading">​</a></h3><p>我们的项目有大量的api请求由goroutine完成，所以我们需要引入一个pool来节省频繁创建goroutine所造成的的开销，同时也可以更简易的调度goroutine，在对github上多个协程池的对比后，我们最终选定了<a href="https://github.com/panjf2000/ants" target="_blank" rel="noopener noreferrer">ants</a>作为我们的调度管理pool。</p><ol><li>最近在测试中偶然发现系统出现了“死锁”的情况，进而采取断网的方式发现“死锁”在极端情况下是稳定出现，经过满篇的log，break，最终把问题定位到了ants的submit方法。这个问题来自于在使用ants pool的过程中，为了实现重试，我们在方法中又递归调用了方法本身，也就是submit task内部又submit一个task，下面是简化后的代码：</li></ol><div class="codeBlockContainer_I0IT language-Go theme-code-block"><div class="codeBlockContent_wNvx" style="color:#393A34;background-color:#f6f8fa"><pre tabindex="0" class="prism-code language-Go codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">func (apiClient *ApiAsyncClient) DoAsync(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   retry int,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">) error {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   return apiClient.scheduler.Submit(func() error {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      _, err := apiClient.Do()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      if err != nil {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         if retry &lt; apiClient.maxRetry {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return apiClient.DoAsync(retry+1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      return err</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><p>在上面的代码块中，可以看到return apiClient.DoAsync(retry+1)这一步递归调用了自己，即在submit中又调用了submit</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="2-深入ants分析">2. 深入ants分析<a class="hash-link" href="#2-深入ants分析" title="Direct link to heading">​</a></h3><p><img loading="lazy" alt="img" src="/assets/images/ants_source_code_1-dbc90cd562952b6434590b8ae7121255.png" width="333" height="231" class="img_E7b_"></p><ul><li>在上面submit源码中可以看到，首先是通过retrieveWorker回去一个worker，然后把task放入到worker的task channel当中，很简单，也看不出来为什么会“dead lock”，没办法，去到retrieveWorker</li></ul><div class="codeBlockContainer_I0IT language-Go theme-code-block"><div class="codeBlockContent_wNvx" style="color:#393A34;background-color:#f6f8fa"><pre tabindex="0" class="prism-code language-Go codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">// retrieveWorker returns a available worker to run the tasks.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">func (p *Pool) retrieveWorker() (w *goWorker) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> spawnWorker := func() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  w = p.workerCache.Get().(*goWorker)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  w.run()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> p.lock.Lock()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> w = p.workers.detach()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> if w != nil { // first try to fetch the worker from the queue</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  p.lock.Unlock()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> } else if capacity := p.Cap(); capacity == -1 || capacity &gt; p.Running() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // if the worker queue is empty and we don't run out of the pool capacity,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // then just spawn a new worker goroutine.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  p.lock.Unlock()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  spawnWorker()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> } else { // otherwise, we'll have to keep them blocked and wait for at least one worker to be put back into pool.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if p.options.Nonblocking {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   p.lock.Unlock()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   return</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> retry:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if p.options.MaxBlockingTasks != 0 &amp;&amp; p.blockingNum &gt;= p.options.MaxBlockingTasks {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   p.lock.Unlock()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   return</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  p.blockingNum++</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  p.cond.Wait() // block and wait for an available worker</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  p.blockingNum--</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var nw int</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if nw = p.Running(); nw == 0 { // awakened by the scavenger</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   p.lock.Unlock()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   if !p.IsClosed() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    spawnWorker()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   return</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if w = p.workers.detach(); w == nil {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   if nw &lt; capacity {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    p.lock.Unlock()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    spawnWorker()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   goto retry</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  p.lock.Unlock()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> return</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><p><img loading="lazy" alt="img" src="/assets/images/ants_source_code_flowchart-6f51973ac906b9029502a2c9063df6ad.png" width="1280" height="481" class="img_E7b_"></p><ul><li>这个方法的大概流程就是先对pool上锁，然后从pool的worker队列中去取一个worker，detach其实就是返回了worker，并且把这个worker从队列中删除掉了，接下来有三种情况<ul><li>如果成功取到worker，解锁p，返回取到的worker</li><li>如果worker队列是空的并且pool的容量没有耗尽，就解锁pool并生成一个新的worker返回给submit</li><li>最后一种情况就是pool容量耗尽了，worker队列也没有空闲的worker，那就要根据我们创建pool时传入的参数来决定下一步情况了<ul><li>首先说一下这里涉及的两个重要参数，一个是capacity，这个值如果在new pool的时候不设置，会是MaxInt32，相当于无限制的goroutine，但是情况不同的是，我们会首先复用空闲的worker，还可以定时清空多余的空闲worker，blockingNum为正在等待的goroutine，初始为0</li><li>如果设置了Nonblocking为true，直接解锁，返回nil，submit就会直接返回一个错误ErrPoolOverload，代表pool超负荷了，不做任何其他处理，submit失败，结束~~</li><li>另一种情况就是没有设置Nonblocking，默认为false，就进入到了一个retry标签，这里面就涉及到了另一个创建pool时候的参数MaxBlockingTasks，这个MaxBlockingTasks就是一个threshold<ul><li>首先判断如果设置了MaxBlockingTasks并且当前blockingNum大于或者等于MaxBlockingTasks，那么直接解锁pool并且返回nil，submit失败，结束~~</li><li>上面的条件不满足，则首先blockingNum++，然后开始wait一直到有worker摸完鱼回来工作，则blockingNum--。问题就在这里了！！！如果所有的worker都在工作（也许是看起来在工作，实际上在摸鱼），这里就会一直wait()，也就是我们自己代码中return后面的DoAsync会一直wait()，从我们自己的项目来讲，就是所有worker这个时候都在submit一个新的task到同一个pool中，而这个时候pool已经满了，导致所有worker都阻塞在了这里，“死锁”也就出现了</li></ul></li></ul></li></ul></li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="3-最后聊几句自己对于golang内存模型的理解">3. 最后聊几句自己对于golang内存模型的理解<a class="hash-link" href="#3-最后聊几句自己对于golang内存模型的理解" title="Direct link to heading">​</a></h3><ol><li>go的调度流程本质上是一个生产-消费的过程，我们利用go func是生产了一个task放到队列中，由系统线程从队列中获取协程然后执行</li><li>讲到go的调度流程，咱们就不能不说一下go的MPG（分别解释一下，就不做深入了，如果有人看，后期再努力整理一份详细聊聊）<ol><li>M 代表着一个内核线程，也可以称为一个工作线程，所有的goroutine都是跑在M之上的</li><li>P可以理解为一个逻辑处理器，主要由P来执行goroutine</li><li>G就是go func封装的这个方法</li></ol></li><li>真正的并发数是由GOMAXPROCS来决定的，并不是提交多少goroutine，并发数就是多少，GOMAXPROCS是由机器的cpu核数来决定的</li><li>所以回到第2部分，pool.cond.wait等待的是绑定上一个goroutine，和其他语言的等待线程具有相似却完全不同的意义，每一个worker是一个G，pool也就是一个队列，而M会从队列中获取可以执行的G，当所有的G都在等待创建新的G时，M全部都处于空闲状态</li></ol><h3 class="anchor anchorWithStickyNavbar_mojV" id="4-解决方案">4. 解决方案<a class="hash-link" href="#4-解决方案" title="Direct link to heading">​</a></h3><ol><li>当然，最靠谱的应该是尽量避免类似这样的递归调用操作</li><li>如果实在不行，可以考虑添加一个sub pool，作为次级队列，让递归生成的G可以在sub pool里等待空闲的M来处理</li></ol><h3 class="anchor anchorWithStickyNavbar_mojV" id="5-对比不同size的pool和两个pool的内存alloc_space和cpu开销">5. 对比不同size的pool和两个pool的内存（alloc_space）和CPU开销<a class="hash-link" href="#5-对比不同size的pool和两个pool的内存alloc_space和cpu开销" title="Direct link to heading">​</a></h3><table><thead><tr><th>Pool size</th><th>CPU(ants)%</th><th>CPU(runtime.gcBgMarkWorker)%</th><th>CPU(runtime.mcall)%</th><th>内存(runtime.allocm)kB</th><th>内存(runtime.gcBgMarkWorker)kB</th><th>内存(root)</th></tr></thead><tbody><tr><td>Two pools(158, 632)</td><td>27.98</td><td>7.73</td><td>25.44</td><td>2050.25</td><td>512.02</td><td>8798</td></tr><tr><td>Pool 158</td><td>28.11</td><td>6.61</td><td>25.08</td><td>2050</td><td></td><td>6661</td></tr><tr><td>Pool 1580</td><td>27.41</td><td>12.96</td><td>23.17</td><td>3075.38</td><td></td><td>10264</td></tr><tr><td>Pool 7900</td><td>25.89</td><td>9.82</td><td>22.52</td><td>3587.94</td><td></td><td>5725</td></tr><tr><td>Pool 790000</td><td>25.12</td><td>12.79</td><td>23.44</td><td>3075.38</td><td></td><td>9748</td></tr></tbody></table><p>runtime.gcBgMarkWorker: 用于标记垃圾对象</p><p>从上面的表格可以看到，可能存在多核的影响，所以对于我们公司现在需要的并发数量级来讲，pool的size对系统影响并不大。</p>]]></content:encoded>
            <category>devlake</category>
            <category>ants</category>
        </item>
    </channel>
</rss>