"use strict";(self.webpackChunkwww=self.webpackChunkwww||[]).push([[78581],{8341:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>o,metadata:()=>i,toc:()=>c});var t=a(87462),r=(a(67294),a(3905));a(61839);const o={slug:"setting-up-devlake-in-aws-ecs-cluster-using-terraform",title:"Setting up Devlake in AWS ECS cluster using Terraform",authors:"TinaZhouHui",tags:["DevLake","AWS","ECS","Terraform"]},s=void 0,i={permalink:"/zh/blog/setting-up-devlake-in-aws-ecs-cluster-using-terraform",editUrl:"https://github.com/apache/incubator-devlake-website/edit/main/blog/2025-04-03-setting-up-devlake-in-aws-ecs-cluster-using-terraform/index.md",source:"@site/blog/2025-04-03-setting-up-devlake-in-aws-ecs-cluster-using-terraform/index.md",title:"Setting up Devlake in AWS ECS cluster using Terraform",description:"This guide provides an alternative to Devlake's Kubernetes setup and will walk you through setting up DevLake in an AWS ECS (Elastic Container Service) cluster using Terraform, providing you with a scalable and maintainable infrastructure as code solution that is also cost effective.",date:"2025-04-03T00:00:00.000Z",formattedDate:"2025\u5e744\u67083\u65e5",tags:[{label:"DevLake",permalink:"/zh/blog/tags/dev-lake"},{label:"AWS",permalink:"/zh/blog/tags/aws"},{label:"ECS",permalink:"/zh/blog/tags/ecs"},{label:"Terraform",permalink:"/zh/blog/tags/terraform"}],readingTime:9.23,hasTruncateMarker:!0,authors:[{name:"TinaZhouHui",title:"Devlake Enthusiast",url:"https://github.com/tinazhouhui",imageURL:"https://avatars.githubusercontent.com/u/63497846?v=4",key:"TinaZhouHui"}],frontMatter:{slug:"setting-up-devlake-in-aws-ecs-cluster-using-terraform",title:"Setting up Devlake in AWS ECS cluster using Terraform",authors:"TinaZhouHui",tags:["DevLake","AWS","ECS","Terraform"]},nextItem:{title:"Quick Start Guide: Setup Your First Engineering Metrics Dashboard in 5 Minutes",permalink:"/zh/blog/Quick-Start-Guide-Setup-Your-First-Engineering-Metrics-Dashboard-in-5-Minutes"}},l={authorsImageUrls:[void 0]},c=[{value:"Storage",id:"storage",level:2},{value:"Cluster",id:"cluster",level:2},{value:"Permissions",id:"permissions",level:3},{value:"Task definition",id:"task-definition",level:3},{value:"Security",id:"security",level:3},{value:"Logs",id:"logs",level:3},{value:"Services",id:"services",level:3},{value:"Load balancer",id:"load-balancer",level:2},{value:"Security",id:"security-1",level:3},{value:"Certificate",id:"certificate",level:3},{value:"ALB",id:"alb",level:3},{value:"DNS Records",id:"dns-records",level:3}],u={toc:c};function d(e){let{components:n,...o}=e;return(0,r.kt)("wrapper",(0,t.Z)({},u,o,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This guide provides an alternative to Devlake's Kubernetes setup and will walk you through setting up DevLake in an AWS ECS (Elastic Container Service) cluster using Terraform, providing you with a scalable and maintainable infrastructure as code solution that is also cost effective."),(0,r.kt)("p",null,"Basic knowledge of AWS ECS, Terraform, and your network where your cluster will be deployed is necessary to follow this guide effectively."),(0,r.kt)("h1",{id:"setting-up-terraform-structure"},"Setting up terraform structure"),(0,r.kt)("p",null,"To configure devlake, we will use a terraform module and pass the necessary variables. The final structure of the module would be something like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"terraform-root/\n\u251c\u2500\u2500 main.tf\n\u251c\u2500\u2500 ...\n\u251c\u2500\u2500 modules/\n\u2502   \u251c\u2500\u2500 devlake/\n\u2502   \u2502   \u251c\u2500\u2500 main.tf\n\u2502   \u2502   \u251c\u2500\u2500 variables.tf\n\u2502   \u2502   \u251c\u2500\u2500 outputs.tf\n\u2502   \u2502   \u251c\u2500\u2500 rds.tf\n\u2502   \u2502   \u251c\u2500\u2500 alb.tf\n\u2502   \u2502   \u251c\u2500\u2500 efs.tf\n\u2502   \u2502   \u251c\u2500\u2500 iam.tf\n\u2502   \u2502   \u251c\u2500\u2500 logs.tf\n\u2502   \u2502   \u251c\u2500\u2500 security.tf\n\u2502   \u2502   \u2514\u2500\u2500 providers.tf\n\u2502   \u2502\n\nAs we go in this tutorial, we will be populating individual files.\n")),(0,r.kt)("p",null,"The AWS provider that is being used is ",(0,r.kt)("inlineCode",{parentName:"p"},'version = "~> 5.91.0"'),"."),(0,r.kt)("p",null,"Fist of, lets populate the ",(0,r.kt)("inlineCode",{parentName:"p"},"variables.tf"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-terraform"},'variable "aws_region" {\n  description = "AWS region where resources will be created"\n  type        = string\n  default     = "YOUR-AWS-REGION" \n}\n\nvariable "tag_name" { # for cost monitoring\n  description = "Name tag for all DevLake resources"\n  type        = string\n  default     = "devlake"\n}\n')),(0,r.kt)("h1",{id:"high-level-architecture"},"High level architecture"),(0,r.kt)("p",null,"The goal is to create an AWS ECS cluster running on fargate spot instances, with an RDS mysql database and efs for grafana as a storage layer. We also need an application load balancer on top which we can optionally configure authentication (like OKTA)."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Architecture Image",src:a(15163).Z,width:"895",height:"671"})),(0,r.kt)("h2",{id:"storage"},"Storage"),(0,r.kt)("p",null,"Let's start with provisioning the necessary storage layer. First of, let's create a database and tis security group in the ",(0,r.kt)("inlineCode",{parentName:"p"},"rds.tf")," file. For that we will need the subnets that you want to deploy your database, the vpc id and the database password (adding them to the ",(0,r.kt)("inlineCode",{parentName:"p"},"variable.tf"),"):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-terraform"},'module "devlake-rds" {\n  source  = "terraform-aws-modules/rds/aws"\n  version = "~> 6.10.0"\n\n  identifier = "devlake-db"\n\n  engine               = "mysql"\n  engine_version       = "8.0"\n  instance_class       = "db.t3.micro"\n  allocated_storage    = 20\n  major_engine_version = "8.0"\n  family               = "mysql8.0"\n\n  manage_master_user_password = false \n  db_name                     = "devlake"\n  username                    = "devlake"\n  password                    = var.db_password # todo\n  port                        = 3306\n\n  create_db_subnet_group = true\n  subnet_ids             = var.private_subnets # todo\n  vpc_security_group_ids = [aws_security_group.rds.id]\n\n  skip_final_snapshot = true\n\n  enabled_cloudwatch_logs_exports = ["error", "general", "slowquery"]\n  create_cloudwatch_log_group     = true\n\n  tags = {\n    Name = var.tag_name\n  }\n}\n\nresource "aws_security_group" "rds" {\n  name        = "devlake-rds"\n  description = "Security group for DevLake RDS"\n  vpc_id      = var.vpc_id # todo\n\n  tags = {\n    Name = var.tag_name\n  }\n\n  ingress {\n    from_port       = 3306\n    to_port         = 3306\n    protocol        = "tcp"\n    security_groups = [aws_security_group.ecs_tasks.id]\n  }\n}\n\n')),(0,r.kt)("p",null,"And also let's create the EFS for grafana and its own security group in ",(0,r.kt)("inlineCode",{parentName:"p"},"efs.tf"),". Since we know that grafana will also need to access this efs, lets go ahead and also create the access point and mount targets:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-terraform"},'resource "aws_efs_file_system" "grafana" {\n  creation_token = "grafana-storage"\n  encrypted      = true\n\n  lifecycle_policy {\n    transition_to_ia = "AFTER_30_DAYS"\n  }\n\n  tags = {\n    Name = var.tag_name\n  }\n}\n\nresource "aws_efs_access_point" "grafana" {\n  file_system_id = aws_efs_file_system.grafana.id\n\n  posix_user {\n    gid = 472\n    uid = 472\n  }\n\n  root_directory {\n    path = "/var/lib/grafana" # from devlake documentation\n    creation_info { # this is necessary to give write permissions\n      owner_gid   = 472\n      owner_uid   = 472\n      permissions = "755"\n    }\n  }\n\n  tags = {\n    Name = var.tag_name\n  }\n}\n\nresource "aws_efs_mount_target" "grafana" {\n  count           = length(var.private_subnets)\n  file_system_id  = aws_efs_file_system.grafana.id\n  subnet_id       = var.private_subnets[count.index]\n  security_groups = [aws_security_group.efs.id]\n}\n\nresource "aws_security_group" "efs" {\n  name        = "grafana-efs"\n  description = "Security group for Grafana EFS mount targets"\n  vpc_id      = var.vpc_id\n\n  tags = {\n    Name = var.tag_name\n  }\n\n  ingress {\n    from_port       = 2049\n    to_port         = 2049\n    protocol        = "tcp"\n    security_groups = [aws_security_group.ecs_tasks.id]\n  }\n} \n')),(0,r.kt)("h2",{id:"cluster"},"Cluster"),(0,r.kt)("p",null,"Let's start with creating a cluster in the module's ",(0,r.kt)("inlineCode",{parentName:"p"},"main.tf"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'resource "aws_ecs_cluster" "devlake" {\n  name = "devlake-cluster"\n\n  setting {\n    name  = "containerInsights"\n    value = "enabled"\n  }\n\n  tags = {\n    Name = var.tag_name\n  }\n}\n')),(0,r.kt)("p",null,"We also need to make sure that the services can talk to each other, therefore we need to create a service discovery namespace. This is crucial to allow for proper host resolution (side note, I also tested this with service connect and it did not work):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'resource "aws_service_discovery_private_dns_namespace" "devlake" {\n  name        = "devlake-ns"\n  description = "Private DNS namespace for DevLake services"\n  vpc         = var.vpc_id\n  tags = {\n    Name = var.tag_name\n  }\n}\n\n# one for each service\nresource "aws_service_discovery_service" "devlake" {\n  name = "devlake" // "config-ui" // "grafana"\n\n  dns_config {\n    namespace_id = aws_service_discovery_private_dns_namespace.devlake.id\n\n    dns_records {\n      ttl  = 10\n      type = "A"\n    }\n\n    routing_policy = "MULTIVALUE"\n  }\n\n  health_check_custom_config {\n    failure_threshold = 1\n  }\n\n  tags = {\n    Name = var.tag_name\n  }\n}\n')),(0,r.kt)("h3",{id:"permissions"},"Permissions"),(0,r.kt)("p",null,"We also need to create IAM roles with necessary permissions to run our cluster. And a separate task role for the grafana container for efs permissions:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'resource "aws_iam_role" "ecs_task_execution_role" {\n  name = "devlake-ecs-task-execution-role"\n\n  assume_role_policy = jsonencode({\n    Version = "2012-10-17"\n    Statement = [\n      {\n        Action = "sts:AssumeRole"\n        Effect = "Allow"\n        Principal = {\n          Service = "ecs-tasks.amazonaws.com"\n        }\n      }\n    ]\n  })\n\n  tags = {\n    Name = var.tag_name\n  }\n}\n\nresource "aws_iam_role_policy_attachment" "ecs_task_execution_role_policy" {\n  role       = aws_iam_role.ecs_task_execution_role.name\n  policy_arn = "arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy"\n}\n\nresource "aws_iam_role_policy_attachment" "ecs_task_execution_role_policy_cloudwatch" {\n  role       = aws_iam_role.ecs_task_execution_role.name\n  policy_arn = "arn:aws:iam::aws:policy/CloudWatchLogsFullAccess"\n}\n\n# IAM Task Role for Grafana container\nresource "aws_iam_role" "grafana_task_role" {\n  name = "devlake-grafana-task-role"\n\n  assume_role_policy = jsonencode({\n    Version = "2012-10-17"\n    Statement = [\n      {\n        Action = "sts:AssumeRole"\n        Effect = "Allow"\n        Principal = {\n          Service = "ecs-tasks.amazonaws.com"\n        }\n      }\n    ]\n  })\n\n  tags = {\n    Name = var.tag_name\n  }\n}\n\n# Policy allowing Grafana task to access EFS\nresource "aws_iam_role_policy" "grafana_efs_access_policy" {\n  name = "grafana-efs-access-policy"\n  role = aws_iam_role.grafana_task_role.id\n\n  policy = jsonencode({\n    Version = "2012-10-17"\n    Statement = [\n      {\n        Effect = "Allow"\n        Action = [\n          "elasticfilesystem:ClientMount",\n          "elasticfilesystem:ClientWrite",\n          "elasticfilesystem:DescribeAccessPoints",\n          "elasticfilesystem:DescribeFileSystems"\n        ]\n        Resource = "*"\n      }\n    ]\n  })\n}\n\n')),(0,r.kt)("h3",{id:"task-definition"},"Task definition"),(0,r.kt)("p",null,"Since the task definition is more or less identical, I will provide an example for one and just the differences in configuration for others."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'resource "aws_ecs_task_definition" "devlake" {\n  family                   = "devlake"\n  network_mode             = "awsvpc"\n  requires_compatibilities = ["FARGATE"]\n  cpu                      = 256\n  memory                   = 512\n  execution_role_arn       = aws_iam_role.ecs_task_execution_role.arn\n\n  container_definitions = jsonencode([\n    {\n      name  = "devlake"\n      image = "devlake.docker.scarf.sh/apache/devlake:v1.0.1"\n      portMappings = [\n        {\n          name          = "devlake-port" \n          containerPort = 8080\n          hostPort      = 8080\n          protocol      = "tcp"\n        }\n      ]\n      environment = [\n        {\n          name  = "DB_URL"\n          value = "mysql://devlake:${var.db_password}@${module.devlake-rds.db_instance_endpoint}/devlake?charset=utf8mb4&parseTime=True&loc=UTC"\n        },\n        {\n          name  = "LOGGING_DIR"\n          value = "/app/logs"\n        },\n        {\n          name  = "TZ"\n          value = "UTC"\n        },\n        {\n          name  = "ENCRYPTION_SECRET"\n          value = var.encryption_secret # your encryption secret\n        },\n      ]\n      logConfiguration = {\n        logDriver = "awslogs"\n        options = {\n          "awslogs-group"         = aws_cloudwatch_log_group.devlake.name\n          "awslogs-region"        = var.aws_region\n          "awslogs-stream-prefix" = "devlake"\n        }\n      }\n    }\n  ])\n\n  tags = {\n    Name = var.tag_name\n  }\n}\n')),(0,r.kt)("p",null,"for config-ui, all is same except for the definition. Take a note on how the endpoints look like, as they are using the namespace we created before:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'resource "aws_ecs_task_definition" "config_ui" {\n  family                   = "config-ui"\n  ...\n  container_definitions = jsonencode([\n    {\n      name  = "config-ui"\n      image = "devlake.docker.scarf.sh/apache/devlake-config-ui:latest"\n      portMappings = [\n        {\n          name          = "config-ui-port" \n          containerPort = 4000\n          hostPort      = 4000\n          protocol      = "tcp"\n        }\n      ]\n      environment = [\n        {\n          "name" : "DEVLAKE_ENDPOINT",\n          "value" : "devlake.devlake-ns:8080"\n        },\n        {\n          name  = "GRAFANA_ENDPOINT"\n          value = "grafana.devlake-ns:3000"\n        },\n        {\n          name  = "TZ"\n          value = "UTC"\n        }\n      ]\n      logConfiguration = {\n        logDriver = "awslogs"\n        options = {\n          "awslogs-group"         = aws_cloudwatch_log_group.config_ui.name\n          "awslogs-region"        = var.aws_region\n          "awslogs-stream-prefix" = "config-ui"\n        }\n      }\n    }\n  ])\n  ...\n}\n')),(0,r.kt)("p",null,"and for grafana, we need to define the task role as well as the volume mount:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'resource "aws_ecs_task_definition" "grafana" {\n  family                   = "grafana"\n  ...\n  task_role_arn            = aws_iam_role.grafana_task_role.arn\n\n  container_definitions = jsonencode([\n    {\n      name  = "grafana"\n      image = "devlake.docker.scarf.sh/apache/devlake-dashboard:v1.0.1"\n      portMappings = [\n        {\n          name          = "grafana-port" \n          containerPort = 3000\n          hostPort      = 3000\n          protocol      = "tcp"\n        }\n      ]\n      environment = [\n        {\n          name  = "GF_SERVER_ROOT_URL"\n          value = "https://devlake.${var.domain_name}/grafana"\n        },\n        {\n          name  = "TZ"\n          value = "UTC"\n        },\n        {\n          name  = "MYSQL_URL"\n          value = module.devlake-rds.db_instance_endpoint\n        },\n        {\n          name  = "MYSQL_DATABASE"\n          value = "devlake"\n        },\n        {\n          name  = "MYSQL_USER"\n          value = "devlake"\n        },\n        {\n          name  = "MYSQL_PASSWORD"\n          value = var.db_password\n        }\n      ]\n      mountPoints = [\n        {\n          sourceVolume  = "grafana-storage"\n          containerPath = "/var/lib/grafana"\n          readOnly      = false\n        }\n      ]\n      logConfiguration = {\n        logDriver = "awslogs"\n        options = {\n          "awslogs-group"         = aws_cloudwatch_log_group.grafana.name\n          "awslogs-region"        = var.aws_region\n          "awslogs-stream-prefix" = "grafana"\n        }\n      }\n    }\n  ])\n\n  volume {\n    name = "grafana-storage"\n    efs_volume_configuration {\n      file_system_id     = aws_efs_file_system.grafana.id\n      root_directory     = "/"\n      transit_encryption = "ENABLED"\n      authorization_config {\n        access_point_id = aws_efs_access_point.grafana.id\n        iam             = "ENABLED"\n      }\n    }\n  }\n  ...\n}\n')),(0,r.kt)("h3",{id:"security"},"Security"),(0,r.kt)("p",null,"To create the service we also need to create a task security group in ",(0,r.kt)("inlineCode",{parentName:"p"},"security.tf"),". "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'resource "aws_security_group" "ecs_tasks" {\n  name        = "devlake-ecs-tasks"\n  description = "Security group for ECS tasks"\n  vpc_id      = var.management_vpc.vpc_id\n\n  ingress {\n    from_port   = 8080\n    to_port     = 8080\n    protocol    = "tcp"\n    self        = true\n    description = "Allow traffic from other ECS tasks to DevLake API"\n  }\n\n  egress {\n    from_port   = 0\n    to_port     = 0\n    protocol    = "-1"\n    cidr_blocks = ["0.0.0.0/0"]\n  }\n\n  tags = {\n    Name = var.tag_name\n  }\n}\n')),(0,r.kt)("p",null,"We also need to add ingress rules to the RDS and EFS security groups in ",(0,r.kt)("inlineCode",{parentName:"p"},"rds.tf")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"efs.tf")," so that the tasks can reach these services."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'resource "aws_security_group" "rds" {\n  ...\n  ingress {\n    from_port       = 3306\n    to_port         = 3306\n    protocol        = "tcp"\n    security_groups = [aws_security_group.ecs_tasks.id]\n  }\n  ...\n}\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'resource "aws_security_group" "efs" {\n  ...\n  ingress {\n    from_port       = 2049\n    to_port         = 2049\n    protocol        = "tcp"\n    security_groups = [aws_security_group.ecs_tasks.id]\n  }\n  ...\n} \n')),(0,r.kt)("h3",{id:"logs"},"Logs"),(0,r.kt)("p",null,"To ensure proper monitoring and debugging capabilities, we'll set up CloudWatch log groups for each service. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'resource "aws_cloudwatch_log_group" "devlake" {\n  name              = "/ecs/devlake"\n  retention_in_days = 30\n\n  tags = {\n    Name = var.tag_name\n  }\n}\n\nresource "aws_cloudwatch_log_group" "config_ui" {\n  name              = "/ecs/config-ui"\n  retention_in_days = 30\n\n  tags = {\n    Name = var.tag_name\n  }\n}\n\nresource "aws_cloudwatch_log_group" "grafana" {\n  name              = "/ecs/grafana"\n  retention_in_days = 30\n\n  tags = {\n    Name = var.tag_name\n  }\n}\n')),(0,r.kt)("h3",{id:"services"},"Services"),(0,r.kt)("p",null,"Now that we have our infrastructure and task definitions set up, let's create the ECS services. We'll deploy three services: DevLake, Config UI, and Grafana. Each service will use Fargate Spot instances for cost optimization and will be configured with service discovery for internal communication."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'resource "aws_ecs_service" "devlake" {\n  name            = "devlake"\n  cluster         = aws_ecs_cluster.devlake.id\n  task_definition = aws_ecs_task_definition.devlake.arn\n  desired_count   = 1\n\n  health_check_grace_period_seconds = 120 # 2 minutes grace period for startup\n\n  capacity_provider_strategy {\n    base              = 1\n    weight            = 100\n    capacity_provider = "FARGATE_SPOT"\n  }\n\n  network_configuration {\n    subnets         = var.management_vpc.private_subnets\n    security_groups = [aws_security_group.ecs_tasks.id]\n  }\n\n  # Configure Service Discovery\n  service_registries {\n    registry_arn = aws_service_discovery_service.devlake.arn\n  }\n\n  deployment_circuit_breaker {\n    enable   = true\n    rollback = true\n  }\n\n  # Configure deployment settings\n  deployment_maximum_percent         = 100\n  deployment_minimum_healthy_percent = 0\n\n  propagate_tags = "SERVICE"\n  tags = {\n    Name = var.tag_name\n  }\n}\n\n')),(0,r.kt)("p",null,"Take a note of the deployment setting in devlake service configuration. This is not needed for config ui or grafana, but only for devlake as only one instance od devlake can connect to DB, therefore we need to first kill the instance completely before starting a new one."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'resource "aws_ecs_service" "config_ui" {\n  name            = "config-ui"\n  task_definition = aws_ecs_task_definition.config_ui.arn\n  \n  ...\n\n  service_registries {\n    registry_arn = aws_service_discovery_service.config_ui.arn\n  }\n\n  # Wait for DevLake to be ready\n  depends_on = [aws_ecs_service.devlake]\n}\n\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'resource "aws_ecs_service" "grafana" {\n  name            = "grafana"\n  task_definition = aws_ecs_task_definition.grafana.arn\n  \n  ...\n\n  service_registries {\n    registry_arn = aws_service_discovery_service.grafana.arn\n  }\n\n  # Wait for both DevLake and Config UI to be ready\n  depends_on = [aws_ecs_service.devlake, aws_ecs_service.config_ui]\n}\n')),(0,r.kt)("p",null,"At this point your containers should be up and running, without any errors regarding DB connection or write permissions to efs. Now we need to setup the load balancer and domain name."),(0,r.kt)("h2",{id:"load-balancer"},"Load balancer"),(0,r.kt)("p",null,"Load balancer helps us route secure traffic to correct containers. We want to have a human readable url, like ",(0,r.kt)("a",{parentName:"p",href:"https://devlake.YOUR-DOMAIN.com"},"https://devlake.YOUR-DOMAIN.com")," to access config ui and ",(0,r.kt)("a",{parentName:"p",href:"https://devlake.YOUR-DOMAIN.com/grafana"},"https://devlake.YOUR-DOMAIN.com/grafana")," to access grafana dashboards."),(0,r.kt)("h3",{id:"security-1"},"Security"),(0,r.kt)("p",null,"Firts we need to create a security group for our alb in ",(0,r.kt)("inlineCode",{parentName:"p"},"security.tf"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'resource "aws_security_group" "alb" {\n  name        = "devlake-alb"\n  description = "Security group for DevLake ALB"\n  vpc_id      = var.vpc_id\n\n  ingress {\n    from_port   = 80\n    to_port     = 80\n    protocol    = "tcp"\n    cidr_blocks = ["0.0.0.0/0"]\n    description = "Allow HTTP traffic"\n  }\n\n  ingress {\n    from_port   = 443\n    to_port     = 443\n    protocol    = "tcp"\n    cidr_blocks = ["0.0.0.0/0"]\n    description = "Allow HTTPS traffic"\n  }\n\n  egress {\n    from_port   = 0\n    to_port     = 0\n    protocol    = "-1"\n    cidr_blocks = ["0.0.0.0/0"]\n    description = "Allow all outbound traffic"\n  }\n\n  tags = {\n    Name = var.tag_name\n  }\n} \n')),(0,r.kt)("p",null,"We also need to allow traffic from alb to the task security groups. This creates a secure path for external traffic to reach our services:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'resource "aws_security_group" "ecs_tasks" {\n  ...\n\n  ingress {\n    from_port       = 8080\n    to_port         = 8080\n    protocol        = "tcp"\n    security_groups = [aws_security_group.alb.id]\n    description     = "Allow traffic from ALB to DevLake API"\n  }\n\n  ingress {\n    from_port       = 4000\n    to_port         = 4000\n    protocol        = "tcp"\n    security_groups = [aws_security_group.alb.id]\n    description     = "Allow traffic from ALB to DevLake UI"\n  }\n\n  ingress {\n    from_port       = 3000\n    to_port         = 3000\n    protocol        = "tcp"\n    security_groups = [aws_security_group.alb.id]\n    description     = "Allow traffic from ALB to Grafana UI"\n  }\n  ...\n}\n')),(0,r.kt)("h3",{id:"certificate"},"Certificate"),(0,r.kt)("p",null,"To create an alb we also need a valid certificate. The certificate must be in the same region as the alb. This are probably created outside of the devlake module."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'resource "aws_acm_certificate" "devlake_cert" {\n  domain_name       = "*.YOUR-DOMAIN.COM"\n  validation_method = "DNS"\n\n  lifecycle {\n    create_before_destroy = true\n  }\n\n  tags = {\n    Name = "devlake"\n  }\n}\n\nresource "aws_route53_record" "cert_validation" {\n  for_each = {\n    for dvo in aws_acm_certificate.devlake_cert.domain_validation_options : dvo.domain_name => {\n      name   = dvo.resource_record_name\n      record = dvo.resource_record_value\n      type   = dvo.resource_record_type\n    }\n  }\n\n  allow_overwrite = true\n  zone_id         = YOUR_DOMAIN_ROUTE53.zone_id\n  name            = each.value.name\n  type            = each.value.type\n  records         = [each.value.record]\n  ttl             = 60\n}\n\n')),(0,r.kt)("h3",{id:"alb"},"ALB"),(0,r.kt)("p",null,"To create alb, we need two variables - public subnets and certificate created in the previous step. "),(0,r.kt)("p",null,"Target groups are essential components that route traffic to our ECS tasks. We'll create two target groups:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Grafana target group - routes traffic to port 3000 and checks health at ",(0,r.kt)("inlineCode",{parentName:"li"},"/api/health")),(0,r.kt)("li",{parentName:"ol"},"Config UI target group - routes traffic to port 4000 and checks health at the root path ",(0,r.kt)("inlineCode",{parentName:"li"},"/"))),(0,r.kt)("p",null,"The health checks ensure that traffic is only routed to healthy containers, maintaining service reliability."),(0,r.kt)("p",null,"Listeners define how the ALB routes incoming traffic to our target groups. "),(0,r.kt)("p",null,"The HTTPS listener uses our ACM certificate and routes traffic based on host headers:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"devlake.${var.domain_name}/grafana*")," \u2192 Grafana target group"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"devlake.${var.domain_name}")," \u2192 Config UI target group")),(0,r.kt)("p",null,"This setup ensures secure access to our services while maintaining proper routing based on the requested paths."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'module "devlake_alb" {\n  source  = "terraform-aws-modules/alb/aws"\n  version = "~> 9.13.0"\n\n  name = "devlake-alb"\n\n  load_balancer_type = "application"\n  internal           = false\n  security_groups    = [aws_security_group.alb.id]\n  subnets            = var.public_subnets\n  vpc_id             = var.vpc_id\n\n  listeners = {\n    https = {\n      port            = 443\n      protocol        = "HTTPS"\n      ssl_policy      = "ELBSecurityPolicy-TLS13-1-2-Res-2021-06"\n      certificate_arn = var.certificate_arn\n      \n      # default action\n      forward = {\n        target_group_key = "devlake-config-ui-tg"\n      }\n\n      rules = {\n        grafana = {\n          priority = 100\n          actions = [{\n            type             = "forward"\n            target_group_key = "devlake-grafana-tg"\n          }]\n          conditions = [{\n            host_header = {\n              values = ["devlake.${var.domain_name}"]\n            }\n            path_pattern = {\n              values = ["/grafana", "/grafana/*"]\n            }\n          }]\n        }\n      }\n    }\n  }\n\n  target_groups = {\n    "devlake-grafana-tg" = {\n      name        = "devlake-grafana-tg"\n      protocol    = "HTTP"\n      port        = 3000\n      target_type = "ip"\n      health_check = {\n        enabled             = true\n        interval            = 30\n        path                = "/api/health"\n        port                = "traffic-port"\n        timeout             = 5\n        healthy_threshold   = 3\n        unhealthy_threshold = 3\n        matcher             = "200"\n      }\n      create_attachment = false\n    },\n\n    "devlake-config-ui-tg" = {\n      name        = "devlake-config-ui-tg"\n      protocol    = "HTTP"\n      port        = 4000\n      target_type = "ip"\n      health_check = {\n        enabled             = true\n        interval            = 30\n        path                = "/"\n        port                = "traffic-port"\n        timeout             = 5\n        healthy_threshold   = 3\n        unhealthy_threshold = 3\n        matcher             = "200"\n      }\n      create_attachment = false\n    }\n  }\n\n  tags = {\n    Name = var.tag_name\n  }\n}\n\n')),(0,r.kt)("h3",{id:"dns-records"},"DNS Records"),(0,r.kt)("p",null,"Finally, to use a human readable url, we need to create DNS records in our route53 that points to our alb. For simplicity's sake, I am referencing directly the alb module's outputs, in reality you will probably need to ooutput these from the devlake module itself: "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'resource "aws_route53_record" "devlake" {\n  zone_id = YOUR_DOMAIN_ROUTE53.zone_id\n  name    = "devlake.YOUR-DOMAIN.com"\n  type    = "A"\n\n  alias {\n    name                   = module.devlake_alb.dns_name\n    zone_id                = module.devlake_alb.zone_id\n    evaluate_target_health = true\n  }\n}\n\n')),(0,r.kt)("p",null,"And thats it, you should be able to access devlake on ",(0,r.kt)("a",{parentName:"p",href:"https://devlake.YOUR-DOMAIN.com"},"https://devlake.YOUR-DOMAIN.com"),"!"),(0,r.kt)("h1",{id:"cost-breakdown"},"Cost breakdown"),(0,r.kt)("p",null," If you want to monitor your costs, first of you need to provide tags with all your resources and second you need to ",(0,r.kt)("a",{parentName:"p",href:"https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/activating-tags.html"},"activate the tag on aws")," so it is registered. "),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Cost breakdown Image",src:a(98611).Z,width:"550",height:"490"})),(0,r.kt)("p",null,"The daily cost is stable on aroun ",(0,r.kt)("inlineCode",{parentName:"p"},"$1.51")," a day, which gives about ",(0,r.kt)("inlineCode",{parentName:"p"},"$45")," a month. The cost does not include the route53 domain though."))}d.isMDXComponent=!0},15163:(e,n,a)=>{a.d(n,{Z:()=>t});const t=a.p+"assets/images/architecture-1587b6206b9702c0989bfb3131be8e1a.png"},98611:(e,n,a)=>{a.d(n,{Z:()=>t});const t=a.p+"assets/images/cost-7efbeef1e68a962824a03e24db631d27.png"}}]);